ca65 V2.19 - Git 5c3ff714a
Main file   : jhe600.s
Current file: jhe600.s

000000r 1               ; Screen Examples, User prompts
000000r 1               ;
000000r 1               ; Load/Save
000000r 1               ; Start         | End           | Move          | Examine
000000r 1               ; 0000 00       | 0000 00       | 0000 00       | 0000 00
000000r 1               ;
000000r 1               ; D/C/W/M  <--- OLD
000000r 1               ;   D)isk                               --- Existing Disk boot routine
000000r 1               ;   C)old start                         --- Existing Cold start basic
000000r 1               ;   W)arm Start                         --- Existing Warm start basic
000000r 1               ;   M)onitor                            --- Existing Monitor
000000r 1               ;       L) Load                         --- Load from serial port
000000r 1               ;       .) Set ADDR mode  0000 -> FFFF
000000r 1               ;       /) Set ADDR mode  00 --> FF  <Return> to skip to next ADDR
000000r 1               ;       G) Start at ADDR
000000r 1               ;   X)modem <--- NEW
000000r 1               ;       R)eceive                        --- Xmodem Recv, First 16 bits is the Start ADDR
000000r 1               ;       S)end                           --- Xmodem Send, First 16 bits is the Start ADDR
000000r 1               ;       B)asic send/save                --- Is basically Xmodem Send with start set to $0000 --> $3FFF (We need a better Idea here)
000000r 1               ;
000000r 1               ;
000000r 1               ;
000000r 1               ; ?????????????
000000r 1               ;     M)ove                             --- Move a block of data
000000r 1               ;     E)xamine                          --- Hex dump addr
000000r 1               ;
000000r 1               ;
000000r 1               ;   Note: SB3 has the UART CLK @ 153.6k which means a Div-1 Baud rate of 153600
000000r 1               ;
000000r 1               ; ---------------------------------------------------------------------------
000000r 1                       .setcpu  "6502"
000000r 1                       .segment "CODE"
000000r 1                       .org     $F800
00F800  1               ;
00F800  1               ;
00F800  1               ;
00F800  1               ; ---------------------------------------------------------------------------
00F800  1               .include        "./c1p_std.inc"
00F800  2               ; ----------------------------------------------------------------------------
00F800  2               zp_bas_JmpWarm                    :=  $0000
00F800  2               zp_bas_MsgPrint                   :=  $0003
00F800  2               zp_bas_usrInVar                   :=  $0006
00F800  2               zp_bas_usrOutVar                  :=  $0008
00F800  2               zp_bas_usrJump                    :=  $000A
00F800  2               zp_bas_usrJumpAddr                :=  $000B
00F800  2               zp_bas_nullCount                  :=  $000D
00F800  2               zp_bas_lineBuffCnt                :=  $000E
00F800  2               zp_bas_termWidth                  :=  $000F
00F800  2               zp_bas_inpColLim                  :=  $0010
00F800  2               zp_bas_integerAddr                :=  $0011
00F800  2               zp_bas_lineBuffer                 :=  $0013     ; 72 Bytes of line buffer
00F800  2               zp_bas_dec2bin                    :=  $005B
00F800  2               zp_bas_scanQuoteFlag              :=  $005C
00F800  2               zp_bas_lineBuffPtr                :=  $005D
00F800  2               zp_bas_dimFlag                    :=  $005E
00F800  2               zp_bas_dataType                   :=  $005F
00F800  2               zp_bas_dataScan                   :=  $0060
00F800  2               zp_bas_subScrFlag                 :=  $0061
00F800  2               zp_bas_inpOrRead                  :=  $0062
00F800  2               zp_bas_evalFlag                   :=  $0063
00F800  2               zp_bas_Ctrl_O                     :=  $0064
00F800  2               zp_bas_tmpStr_1                   :=  $0065
00F800  2               zp_bas_tmpStr_2                   :=  $0068
00F800  2               zp_bas_tmpStr_3                   :=  $006B
00F800  2               zp_bas_tmpStr_4                   :=  $006E
00F800  2               zp_bas_tmpPtr_1                   :=  $0071
00F800  2               zp_bas_tmpPtr_2                   :=  $0073
00F800  2               zp_bas_mulStge_1                  :=  $0075
00F800  2               zp_bas_srcStart                   :=  $0079
00F800  2               zp_bas_snglVars                   :=  $007B
00F800  2               zp_bas_arryVars                   :=  $007D
00F800  2               zp_bas_emptyRAM                   :=  $007F
00F800  2               zp_bas_strings                    :=  $0081
00F800  2               zp_bas_tmpStr                     :=  $0083
00F800  2               zp_bas_memTop                     :=  $0085
00F800  2               zp_bas_currLineNum                :=  $0087
00F800  2               zp_bas_pgmScanPtr                 :=  $008B
00F800  2               zp_bas_curDataStmt                :=  $008D
00F800  2               zp_bas_nxtDataStmt                :=  $008F
00F800  2               zp_bas_find_var_AD0B              :=  $0095
00F800  2               zp_bas_outVarAddr                 :=  $0097
00F800  2               zp_bas_jmp                        :=  $00A1
00F800  2               zp_bas_jmp_addr                   :=  $00A2
00F800  2               zp_bas_nextListLn                 :=  $00AA
00F800  2               zp_bas_prt_num_B962               :=  $00AD
00F800  2               zp_bas_getNxtC                    :=  $00BC
00F800  2               zp_bas_getC                       :=  $00C2
00F800  2               zp_bas_getC_Addr_L                :=  $00C3
00F800  2               zp_bas_getC_Addr_H                :=  $00C4
00F800  2               zp_bas_getC_Exit                  :=  $00D3
00F800  2               zp_bas_randSeed1                  :=  $00D4
00F800  2               zp_bas_randSeed2                  :=  $00D6
00F800  2               zp_freeRAM                        :=  $00D8     ; cc65 Use?     (30 free bytes?)
00F800  2               ;
00F800  2               zp_irq_vec                        :=  $00F7     ; IRQ Vector    (2 Bytes )
00F800  2               zp_nmi_vec                        :=  $00F9     ; NMI Vector    (2 Bytes )
00F800  2               ;
00F800  2               zp_monLoadFlag                    :=  $00FB
00F800  2               zp_monLoadByte                    :=  $00FC
00F800  2               zp_monLoadTmp                     :=  $00FD
00F800  2               zp_monLoadAddrLo                  :=  $00FE
00F800  2               zp_monLoadAddrHi                  :=  $00FF
00F800  2               ;
00F800  2               stack                             :=  $0100     ; Stack init $28 by default (OSI roms use stack for IRQ & NMI)
00F800  2               ;
00F800  2               wa_cursorAtAddr                   :=  $0200
00F800  2               wa_printChar                      :=  $0201
00F800  2               wa_tempChar1                      :=  $0202
00F800  2               wa_loadFlag                       :=  $0203
00F800  2               wa_tempChar2                      :=  $0204
00F800  2               wa_saveFlag                       :=  $0205
00F800  2               wa_repeatRate                     :=  $0206
00F800  2               wa_scrollRtn                      :=  $0207
00F800  2               wa_unused1                        :=  $020F     ; 2 free bytes?
00F800  2               wa_ctrl_C_flag                    :=  $0212
00F800  2               wa_kbdTMP1                        :=  $0213
00F800  2               wa_kbdTMP2                        :=  $0214
00F800  2               wa_kbdTMP3                        :=  $0215
00F800  2               wa_kbdTMP4                        :=  $0216
00F800  2               wa_unused2                        :=  $0217     ; 1 Byte Free?
00F800  2               wa_inputVec                       :=  $0218
00F800  2               wa_outputVec                      :=  $021A
00F800  2               wa_ctrlCVec                       :=  $021C
00F800  2               wa_loadVec                        :=  $021E
00F800  2               wa_saveVec                        :=  $0220
00F800  2               wa_Free                           :=  $0222     ; People use this for small routines?  (222 bytes)
00F800  2               ;
00F800  2               basicPGM                          :=  $0300     ; Basic programs Start here
00F800  2               ;
00F800  2               ;
00F800  2               ;
00F800  2               basicROM_cmdJumpTable             :=  $A000
00F800  2               basicROM_keywordTable             :=  $A084
00F800  2               basicROM_errorMsgTable            :=  $A164
00F800  2               basicROM_msgOutRtn                :=  $A24E
00F800  2               basicROM_Input_str                :=  $A357
00F800  2               basicROM_Init                     :=  $A477
00F800  2               basicROM_Run                      :=  $A5C2
00F800  2               basicROM_CTRL_C                   :=  $A629
00F800  2               basicROM_STOP                     :=  $A638
00F800  2               basicROM_Print_Str                :=  $A8C3
00F800  2               basicROM_compl_16                 :=  $ABD8
00F800  2               basicROM_InVar                    :=  $AE05
00F800  2               basicROM_OutVar                   :=  $AFC1
00F800  2               basicROM_Print_Num                :=  $B962
00F800  2               basicROM_coldStart                :=  $BD11
00F800  2               basicROM_crtRtn                   :=  $BF2D
00F800  2               floppy_piaDRA                     :=  $C000                                                       ; The floppy PIA Data-A port (Input)
00F800  2               floppy_piaCRA                     :=  $C001                                                       ; The floppy PIA Control-A port
00F800  2               floppy_piaDRB                     :=  $C002                                                       ; The floppy PIA Data-B port (Output)
00F800  2               floppy_piaCRB                     :=  $C003                                                       ; The floppy PIA Control-B port
00F800  2               floppy_aciaStatus                 :=  $C010                                                      ; The floppy ACIA Status port
00F800  2               floppy_aciaData                   :=  $C011                                                       ; The floppy ACIA Data port
00F800  2               displayRAM                        :=  $D000
00F800  2               kbdPort                           :=  $DF00                                                       ; The keyboad port lives here
00F800  2               aciaStatus                        :=  $F000                                                       ; The TAPE ACIA Status port
00F800  2               aciaData                          :=  $F001                                                       ; The TAPE ACIA Data port
00F800  2               
00F800  1               ;
00F800  1               ;
00F800  1               ; ---------------------------------------------------------------------------
00F800  1               .include        "./xmodem.s"
00F800  2               ; XMODEM/CRC Receiver for the 65C02
00F800  2               ;
00F800  2               ; By Daryl Rictor & Ross Archer  Aug 2002
00F800  2               ;
00F800  2               ; 21st century code for 20th century CPUs (tm?)
00F800  2               ;
00F800  2               ; A simple file transfer program to allow upload from a console device
00F800  2               ; to the SBC utilizing the x-modem/CRC transfer protocol.  Requires just
00F800  2               ; under 1k of either RAM or ROM, 132DBs of RAM for the receive buffer,
00F800  2               ; and 8DBs of zero page RAM for variable storage.
00F800  2               ;
00F800  2               ;**************************************************************************
00F800  2               ; This implementation of XMODEM/CRC does NOT conform strictly to the
00F800  2               ; XMODEM protocol standard in that it (1) does not accurately time character
00F800  2               ; reception or (2) fall back to the Checksum mode.
00F800  2               
00F800  2               ; (1) For timing, it uses a crude timing loop to provide approximate
00F800  2               ; delays.  These have been calibrated against a 1MHz CPU clock.  I have
00F800  2               ; found that CPU clock speed of up to 5MHz also work but may not in
00F800  2               ; every case.  Windows HyperTerminal worked quite well at both speeds!
00F800  2               ;
00F800  2               ; (2) Most modern terminal programs support XMODEM/CRC which can detect a
00F800  2               ; wider range of transmission errors so the fallback to the simple checksum
00F800  2               ; calculation was not implemented to save space.
00F800  2               ;**************************************************************************
00F800  2               ;
00F800  2               ; Files uploaded via XMODEM-CRC must be
00F800  2               ; in .o64 format -- the first twoDBs are the load address in
00F800  2               ; little-endian format:
00F800  2               ;  FIRST BLOCK
00F800  2               ;     offset(0) = lo(load start address),
00F800  2               ;     offset(1) = hi(load start address)
00F800  2               ;     offset(2) = dataDB (0)
00F800  2               ;     offset(n) = dataDB (n-2)
00F800  2               ;
00F800  2               ; Subsequent blocks
00F800  2               ;     offset(n) = dataDB (n)
00F800  2               ;
00F800  2               ; The TASS assembler and most Commodore 64-based tools generate this
00F800  2               ; data format automatically and you can transfer their .obj/.o64 output
00F800  2               ; file directly.
00F800  2               ;
00F800  2               ; The only time you need to do anything special is if you have
00F800  2               ; a raw memory image file (say you want to load a data
00F800  2               ; table into memory). For XMODEM you'll have to
00F800  2               ; "insert" the start addressDBs to the front of the file.
00F800  2               ; Otherwise, XMODEM would have no idea where to start putting
00F800  2               ; the data.
00F800  2               ;
00F800  2               ;-------------------------- The Code ----------------------------
00F800  2               ;
00F800  2               ; zero page variables (adjust these to suit your needs)
00F800  2               ;
00F800  2               ;
00F800  2               ;            .include        "osic1p.inc"
00F800  2               ;            .include        "osiscreen.inc"
00F800  2               
00F800  2                           .setcpu         "6502"
00F800  2                           .smart          on
00F800  2                           .autoimport     on
00F800  2                           .case           on
00F800  2                           .debuginfo      off
00F800  2                           .importzp       sp, sreg, regsave, regbank
00F800  2                           .importzp       tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
00F800  2                           .FEATURE        STRING_ESCAPES
00F800  2               
00F800  2                           .segment  "STARTUP"
00F800  2                           .segment        "CODE"
00F800  2                           .proc           _main: near
00F800  2               
00F800  2               .export     XM_RomStart
00F800  2               .export     clrScreen
00F800  2               
00F800  2               .ifdef      _StandAlone_
00F800  2                           .org  $7000                             ; Start of program (adjust to your needs)
00F800  2               .endif
00F800  2               
00F800  2               ;
00F800  2               ; Variables, Some live in Display RAM to save space (EG The CRC Table)
00F800  2               ;
00F800  2               SR_Flag         =       $D093
00F800  2               lastblk         =       $D094           ; flag for last block
00F800  2               blkno           =       $D095           ; block number
00F800  2               errcnt          =       $D096           ; error counter 10 is the limit
00F800  2               bflag           =       $D097           ; block flag
00F800  2               
00F800  2               crc             =       $D098           ; CRC lo byte  (two byte variable)
00F800  2               crch            =       $D099           ; CRC hi byte
00F800  2               
00F800  2               
00F800  2               
00F800  2               eofp            =       $D0B5           ; end of file address pointer (2 bytes)
00F800  2               eofph           =       $D0B6           ;  "    "       "       "
00F800  2               debugChar       =       $D0B7
00F800  2               
00F800  2               retry           =       $D090           ; retry counter
00F800  2               retryh          =       $D091
00F800  2               
00F800  2               
00F800  2               
00F800  2               ;
00F800  2               ; Syn600 ROM std variables
00F800  2               zp_bas_tmpStr_1 =       $0065
00F800  2               zp_bas_tmpStr_2 =       $0068
00F800  2               zp_bas_tmpStr_3 =       $006B
00F800  2               zp_bas_tmpStr_4 =       $006E
00F800  2               zp_bas_snglVars =       $007B
00F800  2               zp_bas_arryVars =       $007D
00F800  2               zp_bas_emptyRAM =       $007F
00F800  2               zp_bas_memTop   =       $0085
00F800  2               zp_monLoadFlag  =       $00FB
00F800  2               zp_monLoadByte  =       $00FC
00F800  2               zp_monLoadAddrLo=       $00FE
00F800  2               zp_monLoadAddrHi=       $00FF
00F800  2               ;
00F800  2               displayRAM      =       $D000
00F800  2               ;
00F800  2               
00F800  2               ptr             =       zp_bas_tmpStr_2
00F800  2               ptrh            =       zp_bas_tmpStr_2+1
00F800  2               move_ptr        =       zp_bas_tmpStr_3
00F800  2               move_ptr_h      =       zp_bas_tmpStr_3+1
00F800  2               screen_ptr      =       zp_monLoadByte
00F800  2               ;
00F800  2               BAS_SaveAddr    =       $0000
00F800  2               ;
00F800  2               ;
00F800  2               ; Syn600 Rom entry points
00F800  2               pollKBD         =       $FD00
00F800  2               hex2bin         =       $FE93           ; hex2bin - Convert ascii hex to binary
00F800  2               rollAD          =       $FEDA           ; Roll hex digits into 2 bytes of memory target $FC, FD
00F800  2               fetchByte       =       $FEE9           ; Check Fetch flag; Read from TAPE else KEYB
00F800  2               
00F800  2               aciaInit        =       $FCA6           ; syn600 ROM Serial Acia Init Routine
00F800  2               aciaPut         =       $FCB1           ; syn600 ROM Serial Acia Send byte (A-Reg) Routine
00F800  2               aciaGetW        =       $FE80           ; syn600 ROM Serial Acia Recv Waits for data
00F800  2               
00F800  2               monStart        =       $FE00
00F800  2               disp4bytes      =       $FEAC           ; Display 4 bytes in $FF, FE, FD & FC
00F800  2               dispNybble      =       $FECA           ; Display Nybble - A-Reg Set Y-Reg to zero on entry (Its used as an index)
00F800  2               
00F800  2               ;
00F800  2               ; The ACIA adapter chip
00F800  2               aciaStatus      =       $F000          ; The 6850
00F800  2               aciaData        =       $F001          ; The 6850
00F800  2               
00F800  2               ;
00F800  2               ;
00F800  2               Rbuff           =       $D100           ; temp 132DB receive buffer (In video memory)
00F800  2               ;
00F800  2               ;
00F800  2               ;  tables and constants
00F800  2               ;
00F800  2               ;
00F800  2               ; The crclo & crchi labels are used to point to a lookup table to calculate
00F800  2               ; the CRC for the 128DB data blocks.  There are two implementations of these
00F800  2               ; tables.  One is to use the tables included (defined towards the end of this
00F800  2               ; file) and the other is to build them at run-time.  If building at run-time,
00F800  2               ; then these two labels will need to be un-commented and declared in RAM.
00F800  2               ;
00F800  2               crclo           =       $D200       ; Two 256DB tables for quick lookup  (In video memory)
00F800  2               crchi           =       $D300       ; (should be page-aligned for speed) (In video memory)
00F800  2               ;
00F800  2               ;
00F800  2               ;
00F800  2               ; XMODEM Control Character Constants
00F800  2               SOH     = $01  ; start block
00F800  2               EOT     = $04  ; end of text marker
00F800  2               ACK     = $06  ; good block acknowledged
00F800  2               NAK     = $15  ; bad block acknowledged
00F800  2               CAN     = $18  ; cancel (not standard, not supported)
00F800  2               CR      = $0d  ; carriage return
00F800  2               LF      = $0a  ; line feed
00F800  2               ESC     = $1b  ; ESC to exit
00F800  2               
00F800  2               ;
00F800  2               ;^^^^^^^^^^^^^^^^^^^^^^ Start of Program ^^^^^^^^^^^^^^^^^^^^^^
00F800  2               ;
00F800  2               ; Xmodem/CRC upload routine
00F800  2               ; By Daryl Rictor, July 31, 2002
00F800  2               ;
00F800  2               ; v0.3  tested good minus CRC
00F800  2               ; v0.4  CRC fixed!!! init to $0000 rather than $FFFF as stated
00F800  2               ; v0.5  added CRC tables vs. generation at run time
00F800  2               ; v 1.0 recode for use with SBC2
00F800  2               ; v 1.1 added block 1 masking (block 257 would be corrupted)
00F800  2               ;
00F800  2               
00F800  2               
00F800  2               ;
00F800  2               ;
00F800  2               XM_RomStart:
00F800  2  20 86 F9                 jsr     clrScreen
00F803  2  20 C5 FA                 jsr     XModemInit
00F806  2               GetOpt:
00F806  2               ;           inc     errcnt
00F806  2  20 3B FB                 jsr     DispPrompt
00F809  2  20 00 FD                 jsr     pollKBD
00F80C  2  C9 53                    cmp     #'S'
00F80E  2  F0 0A                    beq     @DoXModemSend
00F810  2               ;
00F810  2               @CheckRecv:
00F810  2  C9 52                    cmp     #'R'
00F812  2  F0 0C                    beq     XModemRecv
00F814  2               ;
00F814  2               @CheckBasSave:
00F814  2  C9 42                    cmp     #'B'
00F816  2  F0 05                    beq     @DoXMBasicSave
00F818  2  D0 EC                    bne     GetOpt
00F81A  2               ;
00F81A  2               @DoXModemSend:
00F81A  2  4C A0 F9                 jmp     XModemSend
00F81D  2               @DoXMBasicSave:
00F81D  2  4C 63 F9                 jmp     XMBasicSave
00F820  2               XModemRecv:
00F820  2               
00F820  2               ;
00F820  2  A9 52                    lda     #'R'
00F822  2  8D 93 D0                 sta     SR_Flag
00F825  2               ;
00F825  2               ;            jsr     XModemInit
00F825  2               ;            jsr     DispRecv
00F825  2  20 19 FB                 jsr     PrintMsg                        ; send prompt and info
00F828  2               ;
00F828  2  A9 01                    lda     #$01
00F82A  2  8D 95 D0                 sta     blkno                           ; set block # to 1
00F82D  2  8D 97 D0                 sta     bflag                           ; set flag to get address from block 1
00F830  2               ;
00F830  2               StartCrc:
00F830  2  A9 43                    lda     #'C'                            ; "C" start with CRC mode
00F832  2  20 B1 FC                 jsr     aciaPut                         ; send it
00F835  2  A9 FF                    lda     #$FF
00F837  2  8D 91 D0                 sta     retryh                          ; set loop counter for ~3 sec delay
00F83A  2  A9 00                    lda     #$00
00F83C  2  8D 98 D0                 sta     crc
00F83F  2  8D 99 D0                 sta     crch                            ; init CRC value
00F842  2  20 F5 FA                 jsr     GetByte                         ; wait for input
00F845  2  B0 14                    bcs     GotByte                         ; DB received, process it
00F847  2  90 E7                    bcc     StartCrc                        ; resend "C"
00F849  2               ;
00F849  2               StartBlk:
00F849  2  A9 FF                    lda     #$FF                            ;
00F84B  2  8D 91 D0                 sta     retryh                          ; set loop counter for ~3 sec delay
00F84E  2  A9 00                    lda     #$00                            ;
00F850  2  8D 98 D0                 sta     crc                             ;
00F853  2  8D 99 D0                 sta     crch                            ; init CRC value
00F856  2  20 F5 FA                 jsr     GetByte                         ; get firstDB of block
00F859  2  90 EE                    bcc     StartBlk                        ; timed out, keep waiting...
00F85B  2               ;
00F85B  2               GotByte:
00F85B  2  C9 1B                    cmp     #ESC                            ; quitting?
00F85D  2  D0 05                    bne     GotByte1                        ; no
00F85F  2  A9 FE                    lda     #$FE                            ; Error code in "A" of desired
00F861  2  4C 00 FE                 jmp     monStart                        ; YES - do BRK or change to RTS if desired
00F864  2               ;
00F864  2               ;
00F864  2               ;
00F864  2               GotByte1:
00F864  2  C9 01                    cmp     #SOH                            ; start of block?
00F866  2  F0 07                    beq     BegBlk                          ; yes
00F868  2  C9 04                    cmp     #EOT                            ;
00F86A  2  D0 5D                    bne     BadCRC                          ; Not SOH or EOT, so flush buffer & send NAK
00F86C  2  4C 2E F9                 jmp     XM_Done                         ; EOT - all done!
00F86F  2               ;
00F86F  2               ;
00F86F  2               ;
00F86F  2               BegBlk:
00F86F  2  A2 00                    ldx     #$00
00F871  2               GetBlk:
00F871  2  A9 FF                    lda     #$ff                            ; 3 sec window to receive characters
00F873  2  8D 91 D0                 sta     retryh                          ;
00F876  2               GetBlk1:
00F876  2  20 F5 FA                 jsr     GetByte                         ; get next character
00F879  2  90 4E                    bcc     BadCRC                          ; chr rcv error, flush and send NAK
00F87B  2               GetBlk2:
00F87B  2  9D 00 D1                 sta     Rbuff,x                         ; good char, save it in the rcv buffer
00F87E  2  E8                       inx                                     ; inc buffer pointer
00F87F  2  E0 84                    cpx     #$84                            ; <01> <FE> <128DBs> <CRCH> <CRCL>
00F881  2  D0 EE                    bne     GetBlk                          ; get 132 characters
00F883  2  A2 00                    ldx     #$00                            ;
00F885  2  BD 00 D1                 lda     Rbuff,x                         ; get block # from buffer
00F888  2  CD 95 D0                 cmp     blkno                           ; compare to expected block #
00F88B  2  F0 0B                    beq     GoodBlk1                        ; matched!
00F88D  2  20 1F FB                 jsr     PrintErr                        ; Unexpected block number - abort
00F890  2  20 0E FB                 jsr     Flush                           ; mismatched - flush buffer and then do BRK
00F893  2  A9 FD                    lda     #$FD                            ; put error code in "A" if desired
00F895  2  4C 00 FE                 jmp     monStart                        ; unexpected block # - fatal error - BRK or RTS
00F898  2               ;
00F898  2               ;
00F898  2               ;
00F898  2               GoodBlk1:
00F898  2  49 FF                    eor     #$ff                            ; 1's comp of block #
00F89A  2  E8                       inx                                     ;
00F89B  2  DD 00 D1                 cmp     Rbuff,x                         ; compare with expected 1's comp of block #
00F89E  2  F0 0B                    beq     GoodBlk2                        ; matched!
00F8A0  2  20 1F FB                 jsr     PrintErr                        ; Unexpected block number - abort
00F8A3  2  20 0E FB                 jsr     Flush                           ; mismatched - flush buffer and then do BRK
00F8A6  2  A9 FC                    lda     #$FC                            ; put error code in "A" if desired
00F8A8  2  4C 00 FE                 jmp     monStart                        ; bad 1's comp of block#
00F8AB  2               ;
00F8AB  2               ;
00F8AB  2               ;
00F8AB  2               GoodBlk2:
00F8AB  2  A0 02                    ldy     #$02                            ;
00F8AD  2               ;
00F8AD  2               XMR_CalcCRC:
00F8AD  2  B9 00 D1                 lda     Rbuff,y                         ; calculate the CRC for the 128DBs of data
00F8B0  2  20 6B FB                 jsr     UpdCRC                          ; could inline sub here for speed
00F8B3  2  C8                       iny                                     ;
00F8B4  2  C0 82                    cpy     #$82                            ; 128DBs
00F8B6  2  D0 F5                    bne     XMR_CalcCRC                     ;
00F8B8  2  B9 00 D1                 lda     Rbuff,y                         ; get hi CRC from buffer
00F8BB  2  CD 99 D0                 cmp     crch                            ; compare to calculated hi CRC
00F8BE  2  D0 09                    bne     BadCRC                          ; bad crc, send NAK
00F8C0  2  C8                       iny                                     ;
00F8C1  2  B9 00 D1                 lda     Rbuff,y                         ; get lo CRC from buffer
00F8C4  2  CD 98 D0                 cmp     crc                             ; compare to calculated lo CRC
00F8C7  2  F0 0B                    beq     GoodCRC                         ; good CRC
00F8C9  2               ;
00F8C9  2               BadCRC:
00F8C9  2  20 0E FB                 jsr     Flush                           ; flush the input port
00F8CC  2  A9 15                    lda     #NAK                            ;
00F8CE  2  20 B1 FC                 jsr     aciaPut                         ; send NAK to resend block
00F8D1  2  4C 49 F8                 jmp     StartBlk                        ; start over, get the block again
00F8D4  2               ;
00F8D4  2               GoodCRC:
00F8D4  2  A2 02                    ldx     #$02                            ;
00F8D6  2  AD 95 D0                 lda     blkno                           ; get the block number
00F8D9  2  C9 01                    cmp     #$01                            ; 1st block?
00F8DB  2  D0 2C                    bne     CopyBlk                         ; no, copy all 128DBs
00F8DD  2  AD 97 D0                 lda     bflag                           ; is it really block 1, not block 257, 513 etc.
00F8E0  2  F0 27                    beq     CopyBlk                         ; no, copy all 128DBs
00F8E2  2               ;
00F8E2  2  BD 00 D1                 lda     Rbuff,x                         ; get target address from 1st 2DBs of blk 1
00F8E5  2  85 68                    sta     ptr                             ; save lo address
00F8E7  2  85 FE                    sta     zp_monLoadAddrLo
00F8E9  2               ;
00F8E9  2  E8                       inx                                     ;
00F8EA  2  BD 00 D1                 lda     Rbuff,x                         ; get hi address
00F8ED  2  85 69                    sta     ptrh                            ; save it
00F8EF  2  85 FF                    sta     zp_monLoadAddrHi
00F8F1  2               ;
00F8F1  2  20 57 F9                 jsr     UpdateDisplay
00F8F4  2               ;
00F8F4  2  A5 68                    lda     ptr
00F8F6  2  C9 00                    cmp     #<BAS_SaveAddr
00F8F8  2  D0 0B                    bne     @Skip
00F8FA  2  A5 69                    lda     ptrh
00F8FC  2  C9 00                    cmp     #>BAS_SaveAddr
00F8FE  2  D0 05                    bne     @Skip
00F900  2               ;
00F900  2  A9 42                    lda     #'B'
00F902  2  8D 93 D0                 sta     SR_Flag
00F905  2               ;
00F905  2               @Skip:
00F905  2  E8                       inx                                     ; point to firstDB of data
00F906  2  CE 97 D0                 dec     bflag                           ; set the flag so we won't get another address
00F909  2               ;
00F909  2               CopyBlk:
00F909  2  A0 00                    ldy     #$00                            ; set offset to zero
00F90B  2               CopyBlk3:
00F90B  2  BD 00 D1                 lda     Rbuff,x                         ; get dataDB from buffer
00F90E  2  91 68                    sta     (ptr),y                         ; save to target
00F910  2  E6 68                    inc     ptr                             ; point to next address
00F912  2  D0 02                    bne     CopyBlk4                        ; did it step over page boundary?
00F914  2  E6 69                    inc     ptr+1                           ; adjust high address for page crossing
00F916  2               ;
00F916  2               CopyBlk4:
00F916  2  E8                       inx                                     ; point to next dataDB
00F917  2  E0 82                    cpx     #$82                            ; is it the lastDB
00F919  2  D0 F0                    bne     CopyBlk3                        ; no, get the next one
00F91B  2               ;
00F91B  2               IncBlk:
00F91B  2  EE 95 D0                 inc     blkno                           ; done.  Inc the block #
00F91E  2  AD 95 D0                 lda     blkno
00F921  2  85 FC                    sta     zp_monLoadByte
00F923  2  20 57 F9                 jsr     UpdateDisplay
00F926  2  A9 06                    lda     #ACK                            ; send ACK
00F928  2  20 B1 FC                 jsr     aciaPut                         ;
00F92B  2  4C 49 F8                 jmp     StartBlk                        ; get next block
00F92E  2               ;
00F92E  2               ;
00F92E  2               ;
00F92E  2               XM_Done:
00F92E  2  A9 06                    lda     #ACK                            ; last block, send ACK and exit.
00F930  2  20 B1 FC                 jsr     aciaPut                         ;
00F933  2               XM_Exit:
00F933  2  D8                       cld                                                                    ; FF00 D8           .
00F934  2  A2 28                    ldx     #$28                                                           ; FF01 A2 28        .(
00F936  2  9A                       txs
00F937  2               ;
00F937  2  20 0E FB                 jsr     Flush                           ; get leftover characters, if any
00F93A  2  20 25 FB                 jsr     PrintGood                       ;
00F93D  2               
00F93D  2  AD 93 D0                 lda     SR_Flag                         ; SR_Flag lives in screen RAM, so grab it before we blow it away!
00F940  2  20 86 F9                 jsr     clrScreen                       ; Clear the screen
00F943  2               ;
00F943  2  C9 42                    cmp     #'B'
00F945  2  F0 0A                    beq     BAS_Start
00F947  2               ;
00F947  2               MON_Start:
00F947  2  C9 52                    cmp     #'R'
00F949  2  F0 03                    beq     PGM_Start
00F94B  2               ;
00F94B  2  4C 00 FE                 jmp     monStart
00F94E  2               ;
00F94E  2               PGM_Start:
00F94E  2  6C FE 00                 jmp     (zp_monLoadAddrLo)
00F951  2               ;
00F951  2               BAS_Start:
00F951  2  4C 74 A2                 jmp     $A274
00F954  2               ;
00F954  2  4C 54 F9     halt:       jmp     halt
00F957  2               ;
00F957  2               ;
00F957  2               UpdateDisplay:
00F957  2  8A                       txa
00F958  2  48                       pha
00F959  2  98                       tya
00F95A  2  48                       pha
00F95B  2  20 AC FE                 jsr     disp4bytes
00F95E  2  68                       pla
00F95F  2  A8                       tay
00F960  2  68                       pla
00F961  2  AA                       tax
00F962  2               
00F962  2  60                       rts
00F963  2               ;
00F963  2               ;
00F963  2               ;================================================================================
00F963  2               XMBasicSave:
00F963  2               ;            cld                                     ; Prep the CPU & Stack
00F963  2               ;            ldx     #$28                            ;
00F963  2               ;            txs                                     ;
00F963  2               ;
00F963  2  A0 00                    ldy     #$00                            ; Display the Send/Recv Flag
00F965  2  A9 42                    lda     #'B'                            ; We are Sending
00F967  2  8D 93 D0                 sta     SR_Flag                         ; It in the display RAM so it just shows up!
00F96A  2               ;
00F96A  2               ;            jsr     XModemInit
00F96A  2               ;
00F96A  2               ;           Basic Start ADDR
00F96A  2  A9 00                    lda     #<BAS_SaveAddr
00F96C  2  85 68                    sta     ptr
00F96E  2  85 FE                    sta     zp_monLoadAddrLo
00F970  2               
00F970  2  A9 00                    lda     #>BAS_SaveAddr
00F972  2  85 69                    sta     ptrh
00F974  2  85 FF                    sta     zp_monLoadAddrHi
00F976  2               ;
00F976  2               ;           Basic End Addr
00F976  2  A5 7F                    lda     zp_bas_emptyRAM
00F978  2  8D B5 D0                 sta     eofp
00F97B  2  A5 80                    lda     zp_bas_emptyRAM+1
00F97D  2  8D B6 D0                 sta     eofph
00F980  2               
00F980  2  20 57 F9                 jsr     UpdateDisplay
00F983  2  4C CD F9                 jmp     XMSendStart
00F986  2               ;
00F986  2               ;================================================================================
00F986  2               clrScreen:
00F986  2  48                   pha
00F987  2  98                   tya
00F988  2  48                   pha
00F989  2  A9 20                lda     #$20
00F98B  2  A0 00                ldy     #$00
00F98D  2               ;
00F98D  2               @Loop:
00F98D  2  99 00 D3             sta     displayRAM+$300,y
00F990  2  99 00 D2             sta     displayRAM+$200,y
00F993  2  99 00 D1             sta     displayRAM+$100,y
00F996  2  99 00 D0             sta     displayRAM,y
00F999  2  C8                   iny
00F99A  2  D0 F1                bne     @Loop
00F99C  2               ;
00F99C  2  68                   pla
00F99D  2  A8                   tay
00F99E  2  68                   pla
00F99F  2  60                   rts
00F9A0  2               ;
00F9A0  2               ;================================================================================
00F9A0  2               ;            .org    $7200
00F9A0  2               ;            .align   256
00F9A0  2               XModemSend:
00F9A0  2               ;            cld                                 ; Prep the CPU & Stack
00F9A0  2               ;            ldx     #$28                        ;
00F9A0  2               ;            txs                                 ;
00F9A0  2               
00F9A0  2  A0 00                    ldy     #$00                        ; Display the Send/Recv Flag
00F9A2  2  A9 53                    lda     #'S'                        ; We are Sending
00F9A4  2  8D 93 D0                 sta     SR_Flag                     ; It in the display RAM so it just shows up!
00F9A7  2               ;
00F9A7  2               ;            jsr     XModemInit
00F9A7  2               ;            jsr     DispSend
00F9A7  2               ;
00F9A7  2               ;
00F9A7  2               ; Get the start address
00F9A7  2  20 2B FB                 jsr     DispStart
00F9AA  2               GetStartAddr:
00F9AA  2  20 DE FA                 jsr     GetAddr
00F9AD  2  C9 0D                    cmp     #CR
00F9AF  2  D0 F9                    bne     GetStartAddr
00F9B1  2               ;
00F9B1  2  A5 FE                    lda     zp_monLoadAddrLo
00F9B3  2  85 68                    sta     ptr
00F9B5  2  A5 FF                    lda     zp_monLoadAddrHi
00F9B7  2  85 69                    sta     ptrh
00F9B9  2               ;
00F9B9  2               ; Get the end address
00F9B9  2  20 33 FB                 jsr     DispEnd
00F9BC  2               GetEndAddr:
00F9BC  2  20 DE FA                 jsr     GetAddr
00F9BF  2  C9 0D                    cmp     #CR
00F9C1  2  D0 F9                    bne     GetEndAddr
00F9C3  2               ;
00F9C3  2  A5 FE                    lda     zp_monLoadAddrLo
00F9C5  2  8D B5 D0                 sta     eofp
00F9C8  2  A5 FF                    lda     zp_monLoadAddrHi
00F9CA  2  8D B6 D0                 sta     eofph
00F9CD  2               ;
00F9CD  2               ;            jsr     DispAddr
00F9CD  2               XMSendStart:
00F9CD  2  20 19 FB                 jsr     PrintMsg                                 ; send prompt and info
00F9D0  2               ;
00F9D0  2  A9 00                    lda     #$00                                     ;
00F9D2  2  8D 96 D0                 sta     errcnt                                   ; error counter set to 0
00F9D5  2  8D 94 D0                 sta     lastblk                                  ; set flag to false
00F9D8  2  A9 01                    lda     #$01                                     ;
00F9DA  2  8D 95 D0                 sta     blkno                                    ; set block # to 1
00F9DD  2               ;
00F9DD  2               Wait4CRC:
00F9DD  2  A9 FF                    lda     #$ff                                     ; 3 seconds
00F9DF  2  8D 91 D0                 sta     retryh                                   ;
00F9E2  2               
00F9E2  2  20 F5 FA                 jsr     GetByte                                  ;
00F9E5  2  90 F6                    bcc     Wait4CRC                                 ; wait for something to come in...
00F9E7  2               
00F9E7  2  8D B7 D0                 sta     debugChar
00F9EA  2               
00F9EA  2  C9 43                    cmp     #'C'                                     ; is it the "C" to start a CRC xfer?
00F9EC  2  F0 07                    beq     SetstAddr                                ; yes
00F9EE  2  C9 1B                    cmp     #ESC                                     ; is it a cancel? <Esc> Key
00F9F0  2  D0 EB                    bne     Wait4CRC                                 ; No, wait for another character
00F9F2  2  4C BF FA                 jmp     PrtAbort                                 ; Print abort msg and exit
00F9F5  2               ;
00F9F5  2               ;
00F9F5  2               ;
00F9F5  2               SetstAddr:
00F9F5  2  A0 00                    ldy     #$00                                     ; init data block offset to 0
00F9F7  2  A2 04                    ldx     #$04                                     ; preload X to Receive buffer
00F9F9  2  A9 01                    lda     #$01                                     ; manually load Blk #1
00F9FB  2  8D 00 D1                 sta     Rbuff                                    ; into 1st byte
00F9FE  2  A9 FE                    lda     #$FE                                     ; load 1's comp of block #
00FA00  2  8D 01 D1                 sta     Rbuff+1                                  ; into 2nd byte
00FA03  2  A5 68                    lda     ptr                                      ; load low byte of start address
00FA05  2  8D 02 D1                 sta     Rbuff+2                                  ; into 3rd byte
00FA08  2  A5 69                    lda     ptrh                                     ; load hi byte of start address
00FA0A  2  8D 03 D1                 sta     Rbuff+3                                  ; into 4th byte
00FA0D  2               
00FA0D  2  4C 3A FA                 jmp     LdBuff1                                  ; jump into buffer load routine
00FA10  2               ;
00FA10  2               LdBuffer:
00FA10  2  AD 95 D0                 lda     blkno
00FA13  2  85 FC                    sta     zp_monLoadByte
00FA15  2  A5 68                    lda     ptr
00FA17  2  85 FE                    sta     zp_monLoadAddrLo
00FA19  2  A5 69                    lda     ptrh
00FA1B  2  85 FF                    sta     zp_monLoadAddrHi
00FA1D  2  20 57 F9                 jsr     UpdateDisplay
00FA20  2               ;
00FA20  2  AD 94 D0                 lda     lastblk                                  ; Was the last block sent?
00FA23  2  F0 03                    beq     LdBuff0                                  ; no, send the next one
00FA25  2               
00FA25  2  4C 2E F9                 jmp     XM_Done
00FA28  2               ;
00FA28  2               LdBuff0:
00FA28  2  A2 02                    ldx     #$02                                     ; init pointers
00FA2A  2  A0 00                    ldy     #$00                                     ;
00FA2C  2  EE 95 D0                 inc     blkno                                    ; inc block counter
00FA2F  2  AD 95 D0                 lda     blkno                                    ;
00FA32  2  8D 00 D1                 sta     Rbuff                                    ; save in 1st byte of buffer
00FA35  2  49 FF                    eor     #$FF                                     ;
00FA37  2  8D 01 D1                 sta     Rbuff+1                                  ; save 1's comp of blkno next
00FA3A  2               
00FA3A  2               LdBuff1:
00FA3A  2  B1 68                    lda     (ptr),y                                  ; save 128 bytes of data
00FA3C  2  9D 00 D1                 sta     Rbuff,x                                  ;
00FA3F  2               LdBuff2:
00FA3F  2  38                       sec                                              ;
00FA40  2  AD B5 D0                 lda     eofp                                     ;
00FA43  2  E5 68                    sbc     ptr                                      ; Are we at the last address?
00FA45  2  D0 16                    bne     LdBuff4                                  ; no, inc pointer and continue
00FA47  2  AD B6 D0                 lda     eofph                                    ;
00FA4A  2  E5 69                    sbc     ptrh                                     ;
00FA4C  2  D0 0F                    bne     LdBuff4                                  ;
00FA4E  2  EE 94 D0                 inc     lastblk                                  ; Yes, Set last byte flag
00FA51  2               LdBuff3:
00FA51  2  E8                       inx                                              ;
00FA52  2  E0 82                    cpx     #$82                                     ; Are we at the end of the 128 byte block?
00FA54  2  F0 12                    beq     XMS_CalcCRC                              ; Yes, calc CRC
00FA56  2  A9 00                    lda     #$00                                     ; Fill rest of 128 bytes with $00
00FA58  2  9D 00 D1                 sta     Rbuff,x                                  ;
00FA5B  2  F0 F4                    beq     LdBuff3                                  ; Branch always
00FA5D  2               
00FA5D  2               LdBuff4:
00FA5D  2  E6 68                    inc     ptr                                      ; Inc address pointer
00FA5F  2  D0 02                    bne     LdBuff5                                  ;
00FA61  2  E6 69                    inc     ptrh                                     ;
00FA63  2               LdBuff5:
00FA63  2  E8                       inx                                              ;
00FA64  2  E0 82                    cpx     #$82                                     ; last byte in block?
00FA66  2  D0 D2                    bne     LdBuff1                                  ; no, get the next
00FA68  2               ;
00FA68  2               XMS_CalcCRC:
00FA68  2  A9 00                    lda     #$00                                     ; yes, calculate the CRC for the 128 bytes
00FA6A  2  8D 98 D0                 sta     crc                                      ;
00FA6D  2  8D 99 D0                 sta     crch                                     ;
00FA70  2  A0 02                    ldy     #$02                                     ;
00FA72  2               @Loop:
00FA72  2  B9 00 D1                 lda     Rbuff,y                                  ;
00FA75  2  20 6B FB                 jsr     UpdCRC                                   ;
00FA78  2  C8                       iny                                              ;
00FA79  2  C0 82                    cpy     #$82                                     ; done yet?
00FA7B  2  D0 F5                    bne     @Loop                                    ; no, get next
00FA7D  2  AD 99 D0                 lda     crch                                     ; save Hi byte of CRC to buffer
00FA80  2  99 00 D1                 sta     Rbuff,y                                  ;
00FA83  2  C8                       iny                                              ;
00FA84  2  AD 98 D0                 lda     crc                                      ; save lo byte of CRC to buffer
00FA87  2  99 00 D1                 sta     Rbuff,y                                  ;
00FA8A  2               ;
00FA8A  2               Resend:
00FA8A  2  A2 00                    ldx     #$00                                     ;
00FA8C  2  A9 01                    lda     #SOH                                     ; Send start block command
00FA8E  2  20 B1 FC                 jsr     aciaPut                                  ;
00FA91  2               ;
00FA91  2               SendBlk:
00FA91  2  BD 00 D1                 lda     Rbuff,x                                  ; Send 133 bytes in buffer to the console
00FA94  2  20 B1 FC                 jsr     aciaPut                                  ;
00FA97  2  E8                       inx                                              ;
00FA98  2  E0 84                    cpx     #$84                                     ; last byte?
00FA9A  2  D0 F5                    bne     SendBlk                                  ; no, get next
00FA9C  2  A9 FF                    lda     #$FF                                     ; yes, set 3 second delay
00FA9E  2  8D 91 D0                 sta     retryh                                   ; and
00FAA1  2  20 F5 FA                 jsr     GetByte                                  ; Wait for Ack/Nack
00FAA4  2  90 0F                    bcc     Seterror                                 ; No chr received after 3 seconds, resend
00FAA6  2  C9 06                    cmp     #ACK                                     ; Chr received... is it:
00FAA8  2  D0 03                    bne     SendBlk2                                 ; --- UGLY: beq can't reach LdBuffer, it' stoo far away!
00FAAA  2  4C 10 FA                 jmp     LdBuffer                                 ; ACK, send next block
00FAAD  2               SendBlk2:
00FAAD  2  C9 15                    cmp     #NAK                                     ;
00FAAF  2  F0 04                    beq     Seterror                                 ; NAK, inc errors and resend
00FAB1  2  C9 1B                    cmp     #ESC                                     ;
00FAB3  2  F0 0A                    beq     PrtAbort                                 ; Esc pressed to abort
00FAB5  2                                                                            ; fall through to error counter
00FAB5  2               Seterror:
00FAB5  2  EE 96 D0                 inc     errcnt                                   ; Inc error counter
00FAB8  2  AD 96 D0                 lda     errcnt                                   ;
00FABB  2  C9 0A                    cmp     #$0A                                     ; are there 10 errors? (Xmodem spec for failure)
00FABD  2  D0 CB                    bne     Resend                                   ; no, resend block
00FABF  2               
00FABF  2               PrtAbort:
00FABF  2  20 1F FB                 jsr     PrintErr
00FAC2  2  4C 33 F9                 jmp     XM_Exit
00FAC5  2               ;
00FAC5  2               ;
00FAC5  2               XModemInit:
00FAC5  2  A9 85                    lda     #<displayRAM+$85
00FAC7  2  85 FC                    sta     screen_ptr
00FAC9  2  A9 D0                    lda     #>displayRAM
00FACB  2  85 FD                    sta     screen_ptr+1
00FACD  2               ;
00FACD  2  A9 00                    lda     #$00
00FACF  2  85 FB                    sta     zp_monLoadFlag
00FAD1  2               ;
00FAD1  2  20 A6 FC                 jsr     aciaInit
00FAD4  2  20 0E FB                 jsr     Flush
00FAD7  2  20 AC FE                 jsr     disp4bytes
00FADA  2               ;            jsr     DispBlocks
00FADA  2               ;            jsr     DispAddr
00FADA  2  20 7F FB                 jsr     MakeCRCTable                             ; Build the CRC tables
00FADD  2  60                       rts
00FADE  2               
00FADE  2               ;
00FADE  2               ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
00FADE  2               GetAddr:
00FADE  2  20 00 FD                 jsr     pollKBD                               ; Get a CHAR from KDB (or TAPE/Serial)
00FAE1  2  C9 0D                    cmp     #CR                                     ; Return Key?
00FAE3  2  F0 0F                    beq     @Done
00FAE5  2               ;
00FAE5  2  20 93 FE                 jsr     hex2bin                                 ; Convert Ascii Hex to binary
00FAE8  2  A2 02                    ldx     #$02                                    ; ???? Why?
00FAEA  2  20 DA FE                 jsr     rollAD                                  ; Roll the incomming Hybble into the ADDR ptr
00FAED  2  B1 FE                    lda     (zp_monLoadAddrLo),y                    ; Grab the data stored at this new addr
00FAEF  2  85 FC                    sta     zp_monLoadByte                          ; Store it for display
00FAF1  2  20 AC FE                 jsr     disp4bytes                              ; Display the Addr & Data  "0000  00"
00FAF4  2               @Done:
00FAF4  2  60                       rts
00FAF5  2               ;
00FAF5  2               ;
00FAF5  2               ; Get a char from the ACIA UART with a time out
00FAF5  2               GetByte:
00FAF5  2  A9 FF                    lda     #$FF                                    ; wait for chr input and cycle timing loop
00FAF7  2  8D 90 D0                 sta     retry                                   ; set low value of timing loop
00FAFA  2  8D 91 D0                 sta     retryh
00FAFD  2               @Loop:
00FAFD  2  20 54 FB                 jsr     aciaGet                                 ; get chr from serial port, don't wait
00FB00  2  B0 0B                    bcs     @Done                                   ; got one, so exit
00FB02  2  CE 90 D0                 dec     retry                                   ; no character received, so dec counter
00FB05  2  D0 F6                    bne     @Loop                                   ;
00FB07  2  CE 91 D0                 dec     retryh                                  ; dec hiDB of counter
00FB0A  2  D0 F1                    bne     @Loop                                   ; look for character again
00FB0C  2  18                       clc                                             ; if loop times out, CLC, else SEC and return
00FB0D  2               @Done:
00FB0D  2  60                       rts                                             ; with character in "A"
00FB0E  2               ;
00FB0E  2               ;
00FB0E  2               ; Drain any incomming cars from the ACIA UART.
00FB0E  2               ; When chars stop we exit
00FB0E  2               Flush:
00FB0E  2  A9 70                    lda     #$70                                    ; flush receive buffer
00FB10  2  8D 91 D0                 sta     retryh                                  ; flush until empty for ~1 sec.
00FB13  2               @Loop:
00FB13  2  20 F5 FA                 jsr     GetByte                                 ; read the port
00FB16  2  B0 FB                    bcs     @Loop                                   ; if chr recvd, wait for another
00FB18  2  60                       rts                                             ; else done
00FB19  2               ;
00FB19  2               PrintMsg:
00FB19  2               @offset = ( strPrintMsg - stringTable )&$FF
00FB19  2  A2 06                    ldx     #@offset
00FB1B  2  20 5E FB                 jsr     aciaStrOut
00FB1E  2  60                       rts
00FB1F  2               
00FB1F  2               ;
00FB1F  2               ;
00FB1F  2               ;
00FB1F  2               PrintErr:
00FB1F  2               @offset = ( strErrMsg - stringTable )&$FF
00FB1F  2  A2 13                    ldx     #@offset
00FB21  2  20 5E FB                 jsr     aciaStrOut
00FB24  2  60                       rts
00FB25  2               ;
00FB25  2               ;
00FB25  2               ;
00FB25  2               PrintGood:
00FB25  2               @offset = ( strGoodMsg - stringTable )&$FF
00FB25  2  A2 1B                    ldx     #@offset
00FB27  2  20 5E FB                 jsr     aciaStrOut
00FB2A  2  60                       rts
00FB2B  2               ;
00FB2B  2               ;
00FB2B  2               .IF 0
00FB2B  2               DispBlocks:
00FB2B  2               @offset = ( strBlocks - stringTable )&$FF
00FB2B  2                           ldx     #@offset
00FB2B  2                           lda     #$CF
00FB2B  2                           jsr     screenOut
00FB2B  2                           rts
00FB2B  2               ;
00FB2B  2               
00FB2B  2               
00FB2B  2               DispAddr:
00FB2B  2               @offset = ( strAddr - stringTable )&$FF
00FB2B  2                           ldx     #@offset
00FB2B  2                           lda     #$A5
00FB2B  2                           jsr     screenOut
00FB2B  2                           rts
00FB2B  2               .ENDIF
00FB2B  2               ;
00FB2B  2               DispStart:
00FB2B  2               @offset = ( strStart - stringTable )&$FF
00FB2B  2  A2 2D                    ldx     #@offset
00FB2D  2  A9 A5                    lda     #$A5
00FB2F  2  20 43 FB                 jsr     screenOut
00FB32  2  60                       rts
00FB33  2               ;
00FB33  2               DispEnd:
00FB33  2               @offset = ( strEnd - stringTable )&$FF
00FB33  2  A2 33                    ldx     #@offset
00FB35  2  A9 A5                    lda     #$A5
00FB37  2  20 43 FB                 jsr     screenOut
00FB3A  2  60                       rts
00FB3B  2               ;
00FB3B  2               .IF 0
00FB3B  2               DispSend:
00FB3B  2               @offset = ( strXM_Send - stringTable )&$FF      ; Get the string location in the Table
00FB3B  2                           ldx     #@offset                    ; Save it for screenOut
00FB3B  2                           lda     #$85                        ; Display @ this offset
00FB3B  2                           jsr     screenOut                   ; Display the string
00FB3B  2                           rts
00FB3B  2               
00FB3B  2               ;
00FB3B  2               DispRecv:
00FB3B  2               @offset = ( strXM_Recv - stringTable )&$FF
00FB3B  2                           ldx     #@offset
00FB3B  2                           lda     #$85
00FB3B  2                           jsr     screenOut
00FB3B  2                           rts
00FB3B  2               .ENDIF
00FB3B  2               ;
00FB3B  2               DispPrompt:
00FB3B  2               @offset = ( strPrompt - stringTable )&$FF
00FB3B  2  A2 00                    ldx     #@offset
00FB3D  2  A9 85                    lda     #$85
00FB3F  2  20 43 FB                 jsr     screenOut
00FB42  2  60                       rts
00FB43  2               ;======================================================================
00FB43  2               ;
00FB43  2               screenOut:
00FB43  2  A0 00                    ldy     #$00
00FB45  2  85 FC                    sta     screen_ptr
00FB47  2               @Loop:
00FB47  2  BD B6 FB                 lda     stringTable,x
00FB4A  2  F0 07                    beq     @Done
00FB4C  2  91 FC                    sta     (screen_ptr),y
00FB4E  2  E8                       inx
00FB4F  2  C8                       iny
00FB50  2  4C 47 FB                 jmp     @Loop
00FB53  2               @Done:
00FB53  2  60                       rts
00FB54  2               ;
00FB54  2               ;
00FB54  2               ;
00FB54  2               aciaGet:
00FB54  2  AD 00 F0                 lda     aciaStatus
00FB57  2  4A                       lsr     a
00FB58  2  90 03                    bcc     @Done
00FB5A  2  AD 01 F0                 lda     aciaData
00FB5D  2               @Done:
00FB5D  2  60                       rts
00FB5E  2               
00FB5E  2               ;
00FB5E  2               ;
00FB5E  2               ;
00FB5E  2               aciaStrOut:
00FB5E  2               @Loop:
00FB5E  2  BD B6 FB                 lda     stringTable,x
00FB61  2  F0 07                    beq     @Done
00FB63  2  20 B1 FC                 jsr     aciaPut
00FB66  2  E8                       inx
00FB67  2  4C 5E FB                 jmp     @Loop
00FB6A  2               @Done:
00FB6A  2  60                       rts
00FB6B  2               
00FB6B  2               
00FB6B  2               
00FB6B  2               
00FB6B  2               ;
00FB6B  2               ;  CRC subroutines
00FB6B  2               ;
00FB6B  2               ;
00FB6B  2  4D 99 D0     UpdCRC:     eor     crc+1                       ; Quick CRC computation with lookup tables
00FB6E  2  AA                       tax                                 ; updates the twoDBs at crc & crc+1
00FB6F  2  AD 98 D0                 lda     crc                         ; with theDB send in the "A" register
00FB72  2  5D 00 D3                 eor     crchi,X
00FB75  2  8D 99 D0                 sta     crc+1
00FB78  2  BD 00 D2                 lda     crclo,X
00FB7B  2  8D 98 D0                 sta     crc
00FB7E  2  60                       rts
00FB7F  2               ;
00FB7F  2               ; Alternate solution is to build the two lookup tables at run-time.  This might
00FB7F  2               ; be desirable if the program is running from ram to reduce binary upload time.
00FB7F  2               ; The following code generates the data for the lookup tables.  You would need to
00FB7F  2               ; un-comment the variable declarations for crclo & crchi in the Tables and Constants
00FB7F  2               ; section above and call this routine to build the tables before calling the
00FB7F  2               ; "xmodem" routine.
00FB7F  2               ;
00FB7F  2               MakeCRCTable:
00FB7F  2  A2 00                    ldx     #$00
00FB81  2  A9 00                    LDA     #$00
00FB83  2               zeroloop:
00FB83  2  9D 00 D2                 sta     crclo,x
00FB86  2  9D 00 D3                 sta     crchi,x
00FB89  2  E8                       inx
00FB8A  2  D0 F7                    bne     zeroloop
00FB8C  2  A2 00                    ldx     #$00
00FB8E  2               fetch:
00FB8E  2  8A                       txa
00FB8F  2  5D 00 D3                 eor     crchi,x
00FB92  2  9D 00 D3                 sta     crchi,x
00FB95  2  A0 08                    ldy     #$08
00FB97  2               fetch1:
00FB97  2  1E 00 D2                 asl     crclo,x
00FB9A  2  3E 00 D3                 rol     crchi,x
00FB9D  2  90 10                    bcc     fetch2
00FB9F  2  BD 00 D3                 lda     crchi,x
00FBA2  2  49 10                    eor     #$10
00FBA4  2  9D 00 D3                 sta     crchi,x
00FBA7  2  BD 00 D2                 lda     crclo,x
00FBAA  2  49 21                    eor     #$21
00FBAC  2  9D 00 D2                 sta     crclo,x
00FBAF  2               fetch2:
00FBAF  2  88                       dey
00FBB0  2  D0 E5                    bne     fetch1
00FBB2  2  E8                       inx
00FBB3  2  D0 D9                    bne     fetch
00FBB5  2  60                       rts
00FBB6  2               
00FBB6  2               ;
00FBB6  2               ;
00FBB6  2               ;                .align  256
00FBB6  2               stringTable:
00FBB6  2  53 2F 52 2F  strPrompt:      .asciiz     "S/R/B"
00FBBA  2  42 00        
00FBBC  2  58 4D 4F 44  strPrintMsg:    .asciiz     "XMODEM/CRC\r\n"
00FBC0  2  45 4D 2F 43  
00FBC4  2  52 43 0D 0A  
00FBC9  2  45 72 72 6F  strErrMsg:      .asciiz     "Error\r\n"
00FBCD  2  72 0D 0A 00  
00FBD1  2  04 0D 0A 04  strGoodMsg:     .byte       EOT,CR,LF,EOT,CR,LF,EOT,CR,LF,CR,LF
00FBD5  2  0D 0A 04 0D  
00FBD9  2  0A 0D 0A     
00FBDC  2  47 6F 6F 64                  .asciiz     "Good\r\n"
00FBE0  2  0D 0A 00     
00FBE3  2               ;strXM_Send:     .asciiz     "Send"
00FBE3  2               ;strXM_Recv:     .asciiz     "Recv"
00FBE3  2               ;strBlocks:      .asciiz     "Blocks"
00FBE3  2               ;strAddr:        .asciiz     "Addr "
00FBE3  2  53 74 61 72  strStart:       .asciiz     "Start"
00FBE7  2  74 00        
00FBE9  2  45 6E 64 20  strEnd:         .asciiz     "End  "
00FBED  2  20 00        
00FBEF  2               
00FBEF  2               ;
00FBEF  2               ; End of string table
00FBEF  2  xx xx xx xx  .align 256
00FBF3  2  xx xx xx xx  
00FBF7  2  xx xx xx xx  
00FC00  2               .endproc
00FC00  2               
00FC00  1               ;
00FC00  1               ;
00FC00  1               ;
00FC00  1               .include        "./jhe-c1p.s"
00FC00  2               ;
00FC00  2                       .org $FC00
00FC00  2               ;        *=     $FC00
00FC00  2               ;
00FC00  2               ; ----------------------------------------------------------------------------
00FC00  2               ; Start of the SYN-600 ROM
00FC00  2               romStart:
00FC00  2               
00FC00  2               ; ----------------------------------------------------------------------------
00FC00  2               ; When you type D you do the Disk boot and end up here
00FC00  2               dskBoot:
00FC00  2  20 0C FC             jsr     dskInit                                                        ; FC00 20 0C FC      ..
00FC03  2  6C FD 00             jmp     (zp_monLoadTmp)                                                ; FC03 6C FD 00     l..
00FC06  2               
00FC06  2               ; ----------------------------------------------------------------------------
00FC06  2  20 0C FC             jsr     dskInit                                                        ; FC06 20 0C FC      ..
00FC09  2  4C 00 FE             jmp     monStart                                                       ; FC09 4C 00 FE     L..
00FC0C  2               
00FC0C  2               ; ----------------------------------------------------------------------------
00FC0C  2               dskInit:                                ;
00FC0C  2  A0 00                ldy     #$00                    ; b0000 0000 - Disable all             ; FC0C A0 00        ..
00FC0E  2  8C 01 C0             sty     floppy_piaCRA                                                  ; FC0E 8C 01 C0     ...
00FC11  2  8C 00 C0             sty     floppy_piaDRA                                                  ; FC11 8C 00 C0     ...
00FC14  2  A2 04                ldx     #$04                    ; b0000 0100 - Watch CA2 state         ; FC14 A2 04        ..
00FC16  2  8E 01 C0             stx     floppy_piaCRA                                                  ; FC16 8E 01 C0     ...
00FC19  2  8C 03 C0             sty     floppy_piaCRB                                                  ; FC19 8C 03 C0     ...
00FC1C  2  88                   dey                                                                    ; FC1C 88           .
00FC1D  2  8C 02 C0             sty     floppy_piaDRB                                                  ; FC1D 8C 02 C0     ...
00FC20  2  8E 03 C0             stx     floppy_piaCRB                                                  ; FC20 8E 03 C0     ...
00FC23  2  8C 02 C0             sty     floppy_piaDRB                                                  ; FC23 8C 02 C0     ...
00FC26  2  A9 FB                lda     #$FB                                                           ; FC26 A9 FB        ..
00FC28  2  D0 09                bne     dskSeekTrk                                                     ; FC28 D0 09        ..
00FC2A  2               dskSeekTrk_0:
00FC2A  2  A9 02                lda     #$02                    ; b0000 0010                           ; FC2A A9 02        ..
00FC2C  2  2C 00 C0             bit     floppy_piaDRA                                                  ; FC2C 2C 00 C0     ,..
00FC2F  2  F0 1C                beq     dskSetDrive                                                    ; FC2F F0 1C        ..
00FC31  2  A9 FF                lda     #$FF                    ; b1111 1111                           ; FC31 A9 FF        ..
00FC33  2               dskSeekTrk:
00FC33  2  8D 02 C0             sta     floppy_piaDRB           ; b1111 1111 - set to all output       ; FC33 8D 02 C0     ...
00FC36  2  20 A5 FC             jsr     dskExitRtn                                                     ; FC36 20 A5 FC      ..
00FC39  2  29 F7                and     #$F7                    ; b1111 0111                           ; FC39 29 F7        ).
00FC3B  2  8D 02 C0             sta     floppy_piaDRB           ; b1111 0111 - Set bit 3 INPUT         ; FC3B 8D 02 C0     ...
00FC3E  2  20 A5 FC             jsr     dskExitRtn                                                     ; FC3E 20 A5 FC      ..
00FC41  2  09 08                ora     #$08                    ; b0000 1000                           ; FC41 09 08        ..
00FC43  2  8D 02 C0             sta     floppy_piaDRB           ; b1111 1111 - Set bit 3 back OUTPUT   ; FC43 8D 02 C0     ...
00FC46  2  A2 18                ldx     #$18                                                           ; FC46 A2 18        ..
00FC48  2  20 91 FC             jsr     dskDelay                                                       ; FC48 20 91 FC      ..
00FC4B  2  F0 DD                beq     dskSeekTrk_0                                                   ; FC4B F0 DD        ..
00FC4D  2               dskSetDrive:
00FC4D  2  A2 7F                ldx     #$7F                    ; b0111 1111                           ; FC4D A2 7F        ..
00FC4F  2  8E 02 C0             stx     floppy_piaDRB           ; b0111 1111 - Set bit 7 INPUT         ; FC4F 8E 02 C0     ...
00FC52  2  20 91 FC             jsr     dskDelay                                                       ; FC52 20 91 FC      ..
00FC55  2               dskWaitIndex:
00FC55  2  AD 00 C0             lda     floppy_piaDRA                                                  ; FC55 AD 00 C0     ...
00FC58  2  30 FB                bmi     dskWaitIndex                                                   ; FC58 30 FB        0.
00FC5A  2               dskWaitReady:
00FC5A  2  AD 00 C0             lda     floppy_piaDRA                                                  ; FC5A AD 00 C0     ...
00FC5D  2  10 FB                bpl     dskWaitReady                                                   ; FC5D 10 FB        ..
00FC5F  2  A9 03                lda     #$03                    ; b0000 0011 - Master Reset            ; FC5F A9 03        ..
00FC61  2  8D 10 C0             sta     floppy_aciaStatus                                              ; FC61 8D 10 C0     ...
00FC64  2  A9 58                lda     #$58                    ; b0101 1000 - RTS,!IRQ,8n2,div-1      ; FC64 A9 58        .X
00FC66  2  8D 10 C0             sta     floppy_aciaStatus                                              ; FC66 8D 10 C0     ...
00FC69  2  20 9C FC             jsr     dskWaitData                                                    ; FC69 20 9C FC      ..
00FC6C  2  85 FE                sta     zp_monLoadAddrLo                                               ; FC6C 85 FE        ..
00FC6E  2  AA                   tax                                                                    ; FC6E AA           .
00FC6F  2  20 9C FC             jsr     dskWaitData                                                    ; FC6F 20 9C FC      ..
00FC72  2  85 FD                sta     zp_monLoadTmp                                                  ; FC72 85 FD        ..
00FC74  2  20 9C FC             jsr     dskWaitData                                                    ; FC74 20 9C FC      ..
00FC77  2  85 FF                sta     zp_monLoadAddrHi                                               ; FC77 85 FF        ..
00FC79  2  A0 00                ldy     #$00                                                           ; FC79 A0 00        ..
00FC7B  2               dskReadSector:
00FC7B  2  20 9C FC             jsr     dskWaitData                                                    ; FC7B 20 9C FC      ..
00FC7E  2  91 FD                sta     (zp_monLoadTmp),y                                              ; FC7E 91 FD        ..
00FC80  2  C8                   iny                                                                    ; FC80 C8           .
00FC81  2  D0 F8                bne     dskReadSector                                                  ; FC81 D0 F8        ..
00FC83  2  E6 FE                inc     zp_monLoadAddrLo                                               ; FC83 E6 FE        ..
00FC85  2  C6 FF                dec     zp_monLoadAddrHi                                               ; FC85 C6 FF        ..
00FC87  2  D0 F2                bne     dskReadSector                                                  ; FC87 D0 F2        ..
00FC89  2  86 FE                stx     zp_monLoadAddrLo                                               ; FC89 86 FE        ..
00FC8B  2  A9 FF                lda     #$FF                    ; b1111 1111 - Set Bit 7 INPUT         ; FC8B A9 FF        ..
00FC8D  2  8D 02 C0             sta     floppy_piaDRB                                                  ; FC8D 8D 02 C0     ...
00FC90  2  60                   rts                                                                    ; FC90 60           `
00FC91  2               
00FC91  2               ; ----------------------------------------------------------------------------
00FC91  2               dskDelay:
00FC91  2  A0 F8                ldy     #$F8                                                           ; FC91 A0 F8        ..
00FC93  2               dskDelayLoopEOR:
00FC93  2  88                   dey                                                                    ; FC93 88           .
00FC94  2  D0 FD                bne     dskDelayLoopEOR                                                ; FC94 D0 FD        ..
00FC96  2  55 FF                eor     zp_monLoadAddrHi,x                                             ; FC96 55 FF        U.
00FC98  2  CA                   dex                                                                    ; FC98 CA           .
00FC99  2  D0 F6                bne     dskDelay                                                       ; FC99 D0 F6        ..
00FC9B  2  60                   rts                                                                    ; FC9B 60           `
00FC9C  2               
00FC9C  2               ; ----------------------------------------------------------------------------
00FC9C  2               dskWaitData:
00FC9C  2  AD 10 C0             lda     floppy_aciaStatus                                              ; FC9C AD 10 C0     ...
00FC9F  2  4A                   lsr     a                                                              ; FC9F 4A           J
00FCA0  2  90 FA                bcc     dskWaitData                                                    ; FCA0 90 FA        ..
00FCA2  2  AD 11 C0             lda     floppy_aciaData                                                ; FCA2 AD 11 C0     ...
00FCA5  2               dskExitRtn:
00FCA5  2  60                   rts                                                                    ; FCA5 60           `
00FCA6  2               
00FCA6  2               ; ----------------------------------------------------------------------------
00FCA6  2               ; Init the ACIA
00FCA6  2               aciaInit:
00FCA6  2  A9 03                lda     #$03                    ; b0000 0011 - Master Reset            ; FCA6 A9 03        ..
00FCA8  2  8D 00 F0             sta     aciaStatus                                                     ; FCA8 8D 00 F0     ...
00FCAB  2  A9 11                lda     #$11                    ; b0001 0001 - !RTS,!IRQ,8n2,Div-16    ; FCAB A9 11        ..
00FCAD  2  8D 00 F0             sta     aciaStatus                                                     ; FCAD 8D 00 F0     ...
00FCB0  2  60                   rts                                                                    ; FCB0 60           `
00FCB1  2               
00FCB1  2               ; ----------------------------------------------------------------------------
00FCB1  2               ; Send char to the ACIA
00FCB1  2               aciaPut:
00FCB1  2  48                   pha                                                                    ; FCB1 48           H
00FCB2  2               aciaPut_wait:
00FCB2  2  AD 00 F0             lda     aciaStatus                                                     ; FCB2 AD 00 F0     ...
00FCB5  2  4A                   lsr     a                                                              ; FCB5 4A           J
00FCB6  2  4A                   lsr     a                                                              ; FCB6 4A           J
00FCB7  2  90 F9                bcc     aciaPut_wait                                                   ; FCB7 90 F9        ..
00FCB9  2  68                   pla                                                                    ; FCB9 68           h
00FCBA  2  8D 01 F0             sta     aciaData                                                       ; FCBA 8D 01 F0     ...
00FCBD  2  60                   rts                                                                    ; FCBD 60           `
00FCBE  2               
00FCBE  2               ; ----------------------------------------------------------------------------
00FCBE  2               ; Strobe the KEYB column port
00FCBE  2               kbdStrobe:
00FCBE  2  49 FF                eor     #$FF                    ; b1111 1111                           ; FCBE 49 FF        I.
00FCC0  2  8D 00 DF             sta     kbdPort                                                        ; FCC0 8D 00 DF     ...
00FCC3  2  49 FF                eor     #$FF                    ; b1111 1111                           ; FCC3 49 FF        I.
00FCC5  2  60                   rts                                                                    ; FCC5 60           `
00FCC6  2               
00FCC6  2               ; ----------------------------------------------------------------------------
00FCC6  2               ; Read the KEYB row from port
00FCC6  2               kbdGet:
00FCC6  2  48                   pha                                                                    ; FCC6 48           H
00FCC7  2  20 CF FC             jsr     kbdGetRaw                                                      ; FCC7 20 CF FC      ..
00FCCA  2  AA                   tax                                                                    ; FCCA AA           .
00FCCB  2  68                   pla                                                                    ; FCCB 68           h
00FCCC  2  CA                   dex                                                                    ; FCCC CA           .
00FCCD  2  E8                   inx                                                                    ; FCCD E8           .
00FCCE  2  60                   rts                                                                    ; FCCE 60           `
00FCCF  2               
00FCCF  2               ; ----------------------------------------------------------------------------
00FCCF  2               ; Read the KEYB row from port
00FCCF  2               kbdGetRaw:
00FCCF  2  AD 00 DF             lda     kbdPort                                                        ; FCCF AD 00 DF     ...
00FCD2  2  49 FF                eor     #$FF                    ; b1111 1111                           ; FCD2 49 FF        I.
00FCD4  2  60                   rts                                                                    ; FCD4 60           `
00FCD5  2               
00FCD5  2               ; ----------------------------------------------------------------------------
00FCD5  2               irqJump:
00FCD5  2  6C F7 00             jmp     (zp_irq_vec)                                                   ; FCD5
00FCD8  2               ;
00FCD8  2               nmiJump:
00FCD8  2  6C F9 00             jmp     (zp_nmi_vec)                                                   ; FCD8
00FCDB  2               ;
00FCDB  2               intrStub:
00FCDB  2  40                   rti
00FCDC  2               ;
00FCDC  2               initIrqNmi:
00FCDC  2  A9 DB                lda     #<intrStub
00FCDE  2  85 F7                sta     zp_irq_vec
00FCE0  2  85 F9                sta     zp_nmi_vec
00FCE2  2  A9 FC                lda     #>intrStub
00FCE4  2  85 F8                sta     zp_irq_vec+1
00FCE6  2  85 FA                sta     zp_nmi_vec+1
00FCE8  2               ;
00FCE8  2  60                   rts
00FCE9  2               ;
00FCE9  2  FF FF FF FF          .res    $FD00-*, $FF
00FCED  2  FF FF FF FF  
00FCF1  2  FF FF FF FF  
00FD00  2               ;
00FD00  2               ; ----------------------------------------------------------------------------
00FD00  2               ; Keyboard poll routine
00FD00  2               pollKBD:
00FD00  2  8A                   txa                                                                    ; FD00 8A           .
00FD01  2  48                   pha                                                                    ; FD01 48           H
00FD02  2  98                   tya                                                                    ; FD02 98           .
00FD03  2  48                   pha                                                                    ; FD03 48           H
00FD04  2               pollKBD_firstRow:
00FD04  2  A9 01                lda     #$01                                                           ; FD04 A9 01        ..
00FD06  2               pollKBD_readKey:
00FD06  2  20 BE FC             jsr     kbdStrobe                                                      ; FD06 20 BE FC      ..
00FD09  2  20 C6 FC             jsr     kbdGet                                                         ; FD09 20 C6 FC      ..
00FD0C  2  D0 05                bne     pollKBD_checkEnd                                               ; FD0C D0 05        ..
00FD0E  2               pollKBD_nextRow:
00FD0E  2  0A                   asl     a                                                              ; FD0E 0A           .
00FD0F  2  D0 F5                bne     pollKBD_readKey                                                ; FD0F D0 F5        ..
00FD11  2  F0 53                beq     pollKBD_noKey                                                  ; FD11 F0 53        .S
00FD13  2               pollKBD_checkEnd:
00FD13  2  4A                   lsr     a                                                              ; FD13 4A           J
00FD14  2  90 09                bcc     pollKBD_decode                                                 ; FD14 90 09        ..
00FD16  2  2A                   rol     a                                                              ; FD16 2A           *
00FD17  2  E0 21                cpx     #$21                                                           ; FD17 E0 21        .!
00FD19  2  D0 F3                bne     pollKBD_nextRow                                                ; FD19 D0 F3        ..
00FD1B  2  A9 1B                lda     #$1B                                                           ; FD1B A9 1B        ..
00FD1D  2  D0 21                bne     pollKBD_decodeDone                                             ; FD1D D0 21        .!
00FD1F  2               pollKBD_decode:
00FD1F  2  20 C8 FD             jsr     pollKBD_getColumn                                              ; FD1F 20 C8 FD      ..
00FD22  2  98                   tya                                                                    ; FD22 98           .
00FD23  2  8D 13 02             sta     wa_kbdTMP1                                                     ; FD23 8D 13 02     ...
00FD26  2  0A                   asl     a                                                              ; FD26 0A           .
00FD27  2  0A                   asl     a                                                              ; FD27 0A           .
00FD28  2  0A                   asl     a                                                              ; FD28 0A           .
00FD29  2  38                   sec                                                                    ; FD29 38           8
00FD2A  2  ED 13 02             sbc     wa_kbdTMP1                                                     ; FD2A ED 13 02     ...
00FD2D  2  8D 13 02             sta     wa_kbdTMP1                                                     ; FD2D 8D 13 02     ...
00FD30  2  8A                   txa                                                                    ; FD30 8A           .
00FD31  2  4A                   lsr     a                                                              ; FD31 4A           J
00FD32  2  20 C8 FD             jsr     pollKBD_getColumn                                              ; FD32 20 C8 FD      ..
00FD35  2  D0 2F                bne     pollKBD_noKey                                                  ; FD35 D0 2F        ./
00FD37  2  18                   clc                                                                    ; FD37 18           .
00FD38  2  98                   tya                                                                    ; FD38 98           .
00FD39  2  6D 13 02             adc     wa_kbdTMP1                                                     ; FD39 6D 13 02     m..
00FD3C  2  A8                   tay                                                                    ; FD3C A8           .
00FD3D  2  B9 CF FD             lda     validKeysR0,y                                                  ; FD3D B9 CF FD     ...
00FD40  2               pollKBD_decodeDone:
00FD40  2  CD 15 02             cmp     wa_kbdTMP3                                                     ; FD40 CD 15 02     ...
00FD43  2  D0 26                bne     pollKBD_invalid                                                ; FD43 D0 26        .&
00FD45  2  CE 14 02             dec     wa_kbdTMP2                                                     ; FD45 CE 14 02     ...
00FD48  2  F0 2B                beq     LFD75                                                          ; FD48 F0 2B        .+
00FD4A  2  A0 05                ldy     #$05                                                           ; FD4A A0 05        ..
00FD4C  2               pollKBD_debounce:
00FD4C  2  A2 C8                ldx     #$C8                                                           ; FD4C A2 C8        ..
00FD4E  2               pollKBD_debounceLoop:
00FD4E  2  CA                   dex                                                                    ; FD4E CA           .
00FD4F  2  D0 FD                bne     pollKBD_debounceLoop                                           ; FD4F D0 FD        ..
00FD51  2  88                   dey                                                                    ; FD51 88           .
00FD52  2  D0 F8                bne     pollKBD_debounce                                               ; FD52 D0 F8        ..
00FD54  2  F0 AE                beq     pollKBD_firstRow                                               ; FD54 F0 AE        ..
00FD56  2               pollKBD_debounceDone:
00FD56  2  C9 01                cmp     #$01                                                           ; FD56 C9 01        ..
00FD58  2  F0 35                beq     LFD8F                                                          ; FD58 F0 35        .5
00FD5A  2  A0 00                ldy     #$00                                                           ; FD5A A0 00        ..
00FD5C  2  C9 02                cmp     #$02                                                           ; FD5C C9 02        ..
00FD5E  2  F0 47                beq     pollKBD_SaveResults                                            ; FD5E F0 47        .G
00FD60  2  A0 C0                ldy     #$C0                                                           ; FD60 A0 C0        ..
00FD62  2  C9 20                cmp     #$20                                                           ; FD62 C9 20        .
00FD64  2  F0 41                beq     pollKBD_SaveResults                                            ; FD64 F0 41        .A
00FD66  2               pollKBD_noKey:
00FD66  2  A9 00                lda     #$00                                                           ; FD66 A9 00        ..
00FD68  2  8D 16 02             sta     wa_kbdTMP4                                                     ; FD68 8D 16 02     ...
00FD6B  2               pollKBD_invalid:
00FD6B  2  8D 15 02             sta     wa_kbdTMP3                                                     ; FD6B 8D 15 02     ...
00FD6E  2  A9 02                lda     #$02                                                           ; FD6E A9 02        ..
00FD70  2  8D 14 02             sta     wa_kbdTMP2                                                     ; FD70 8D 14 02     ...
00FD73  2  D0 8F                bne     pollKBD_firstRow                                               ; FD73 D0 8F        ..
00FD75  2               LFD75:
00FD75  2  A2 96                ldx     #$96                                                           ; FD75 A2 96        ..
00FD77  2  CD 16 02             cmp     wa_kbdTMP4                                                     ; FD77 CD 16 02     ...
00FD7A  2  D0 02                bne     LFD7E                                                          ; FD7A D0 02        ..
00FD7C  2  A2 14                ldx     #$14                                                           ; FD7C A2 14        ..
00FD7E  2               LFD7E:
00FD7E  2  8E 14 02             stx     wa_kbdTMP2                                                     ; FD7E 8E 14 02     ...
00FD81  2  8D 16 02             sta     wa_kbdTMP4                                                     ; FD81 8D 16 02     ...
00FD84  2  A9 01                lda     #$01                                                           ; FD84 A9 01        ..
00FD86  2  20 BE FC             jsr     kbdStrobe                                                      ; FD86 20 BE FC      ..
00FD89  2  20 CF FC             jsr     kbdGetRaw                                                      ; FD89 20 CF FC      ..
00FD8C  2  4A                   lsr     a                                                              ; FD8C 4A           J
00FD8D  2  90 33                bcc     LFDC2                                                          ; FD8D 90 33        .3
00FD8F  2               LFD8F:
00FD8F  2  AA                   tax                                                                    ; FD8F AA           .
00FD90  2  29 03                and     #$03                                                           ; FD90 29 03        ).
00FD92  2  F0 0B                beq     LFD9F                                                          ; FD92 F0 0B        ..
00FD94  2  A0 10                ldy     #$10                                                           ; FD94 A0 10        ..
00FD96  2  AD 15 02             lda     wa_kbdTMP3                                                     ; FD96 AD 15 02     ...
00FD99  2  10 0C                bpl     pollKBD_SaveResults                                            ; FD99 10 0C        ..
00FD9B  2  A0 F0                ldy     #$F0                                                           ; FD9B A0 F0        ..
00FD9D  2  D0 08                bne     pollKBD_SaveResults                                            ; FD9D D0 08        ..
00FD9F  2               LFD9F:
00FD9F  2  A0 00                ldy     #$00                                                           ; FD9F A0 00        ..
00FDA1  2  E0 20                cpx     #$20                                                           ; FDA1 E0 20        .
00FDA3  2  D0 02                bne     pollKBD_SaveResults                                            ; FDA3 D0 02        ..
00FDA5  2  A0 C0                ldy     #$C0                                                           ; FDA5 A0 C0        ..
00FDA7  2               pollKBD_SaveResults:
00FDA7  2  AD 15 02             lda     wa_kbdTMP3                                                     ; FDA7 AD 15 02     ...
00FDAA  2  29 7F                and     #$7F                                                           ; FDAA 29 7F        ).
00FDAC  2  C9 20                cmp     #$20                                                           ; FDAC C9 20        .
00FDAE  2  F0 07                beq     pollKBD_Exit                                                   ; FDAE F0 07        ..
00FDB0  2  8C 13 02             sty     wa_kbdTMP1                                                     ; FDB0 8C 13 02     ...
00FDB3  2  18                   clc                                                                    ; FDB3 18           .
00FDB4  2  6D 13 02             adc     wa_kbdTMP1                                                     ; FDB4 6D 13 02     m..
00FDB7  2               pollKBD_Exit:
00FDB7  2  8D 13 02             sta     wa_kbdTMP1                                                     ; FDB7 8D 13 02     ...
00FDBA  2  68                   pla                                                                    ; FDBA 68           h
00FDBB  2  A8                   tay                                                                    ; FDBB A8           .
00FDBC  2  68                   pla                                                                    ; FDBC 68           h
00FDBD  2  AA                   tax                                                                    ; FDBD AA           .
00FDBE  2  AD 13 02             lda     wa_kbdTMP1                                                     ; FDBE AD 13 02     ...
00FDC1  2  60                   rts                                                                    ; FDC1 60           `
00FDC2  2               
00FDC2  2               ; ----------------------------------------------------------------------------
00FDC2  2               LFDC2:
00FDC2  2  D0 92                bne     pollKBD_debounceDone                                           ; FDC2 D0 92        ..
00FDC4  2  A0 20                ldy     #$20                                                           ; FDC4 A0 20        .
00FDC6  2  D0 DF                bne     pollKBD_SaveResults                                            ; FDC6 D0 DF        ..
00FDC8  2               pollKBD_getColumn:
00FDC8  2  A0 08                ldy     #$08                                                           ; FDC8 A0 08        ..
00FDCA  2               pollKBD_getColumnNext:
00FDCA  2  88                   dey                                                                    ; FDCA 88           .
00FDCB  2  0A                   asl     a                                                              ; FDCB 0A           .
00FDCC  2  90 FC                bcc     pollKBD_getColumnNext                                          ; FDCC 90 FC        ..
00FDCE  2  60                   rts                                                                    ; FDCE 60           `
00FDCF  2               
00FDCF  2               ; ----------------------------------------------------------------------------
00FDCF  2               validKeysR0:
00FDCF  2  D0 BB                .byte   $D0,$BB                                                        ; FDCF D0 BB        ..
00FDD1  2  2F 20 5A 41          .byte   "/ ZAQ"                                                        ; FDD1 2F 20 5A 41 51/ ZAQ
00FDD5  2  51           
00FDD6  2               validKeysR1:
00FDD6  2  2C 4D 4E 42          .byte   ",MNBVCX"                                                      ; FDD6 2C 4D 4E 42 56 43 58,MNBVCX
00FDDA  2  56 43 58     
00FDDD  2               validKeysR2:
00FDDD  2  4B 4A 48 47          .byte   "KJHGFDS"                                                      ; FDDD 4B 4A 48 47 46 44 53KJHGFDS
00FDE1  2  46 44 53     
00FDE4  2               validKeysR3:
00FDE4  2  49 55 59 54          .byte   "IUYTREW"                                                      ; FDE4 49 55 59 54 52 45 57IUYTREW
00FDE8  2  52 45 57     
00FDEB  2               validKeysR4:
00FDEB  2  00 00 0D 0A          .byte   $00,$00,$0D,$0A                                                ; FDEB 00 00 0D 0A  ....
00FDEF  2  4F 4C 2E             .byte   "OL."                                                          ; FDEF 4F 4C 2E     OL.
00FDF2  2               validKeysR5:
00FDF2  2  00 FF                .byte   $00,$FF                                                        ; FDF2 00 FF        ..
00FDF4  2  2D                   .byte   "-"                                                            ; FDF4 2D           -
00FDF5  2  BA                   .byte   $BA                                                            ; FDF5 BA           .
00FDF6  2  30                   .byte   "0"                                                            ; FDF6 30           0
00FDF7  2  B9 B8                .byte   $B9,$B8                                                        ; FDF7 B9 B8        ..
00FDF9  2               ; ----------------------------------------------------------------------------
00FDF9  2               validKeysR6:
00FDF9  2  B7 B6 B5 B4          .byte   $B7,$B6,$B5,$B4,$B3,$B2,$B1                                    ; FDF9 B7 B6 B5 B4 B3 B2 B1.......
00FDFD  2  B3 B2 B1     
00FE00  2               ; ----------------------------------------------------------------------------
00FE00  2               ; When you type M to enter the monitor you end up here
00FE00  2               monStart:
00FE00  2  A2 28                ldx     #$28                                                           ; FE00 A2 28        .(
00FE02  2  9A                   txs                                                                    ; FE02 9A           .
00FE03  2  D8                   cld                                                                    ; FE03 D8           .
00FE04  2  EA                   nop                                                                    ; FE04 EA           .
00FE05  2  EA                   nop                                                                    ; FE05 EA           .
00FE06  2  EA                   nop                                                                    ; FE06 EA           .
00FE07  2  EA                   nop                                                                    ; FE07 EA           .
00FE08  2  EA                   nop                                                                    ; FE08 EA           .
00FE09  2  EA                   nop                                                                    ; FE09 EA           .
00FE0A  2  EA                   nop                                                                    ; FE0A EA           .
00FE0B  2               ; Monitor - Initialise everything
00FE0B  2               mon_init:
00FE0B  2  EA                   nop                                                                    ; FE0B EA           .
00FE0C  2  A2 D4                ldx     #$D4                                                           ; FE0C A2 D4        ..
00FE0E  2  A9 D0                lda     #$D0                                                           ; FE0E A9 D0        ..
00FE10  2  85 FF                sta     zp_monLoadAddrHi                                               ; FE10 85 FF        ..
00FE12  2  A9 00                lda     #$00                                                           ; FE12 A9 00        ..
00FE14  2  85 FE                sta     zp_monLoadAddrLo                                               ; FE14 85 FE        ..
00FE16  2  85 FB                sta     zp_monLoadFlag                                                 ; FE16 85 FB        ..
00FE18  2  A8                   tay                                                                    ; FE18 A8           .
00FE19  2  A9 20                lda     #$20                                                           ; FE19 A9 20        .
00FE1B  2               ; Monitor - Display char on screen
00FE1B  2               mon_DspChar:
00FE1B  2  91 FE                sta     (zp_monLoadAddrLo),y                                           ; FE1B 91 FE        ..
00FE1D  2  C8                   iny                                                                    ; FE1D C8           .
00FE1E  2  D0 FB                bne     mon_DspChar                                                    ; FE1E D0 FB        ..
00FE20  2  E6 FF                inc     zp_monLoadAddrHi                                               ; FE20 E6 FF        ..
00FE22  2  E4 FF                cpx     zp_monLoadAddrHi                                               ; FE22 E4 FF        ..
00FE24  2  D0 F5                bne     mon_DspChar                                                    ; FE24 D0 F5        ..
00FE26  2  84 FF                sty     zp_monLoadAddrHi                                               ; FE26 84 FF        ..
00FE28  2  F0 19                beq     mon_DspAddr                                                    ; FE28 F0 19        ..
00FE2A  2               ; Monitor - Main loop
00FE2A  2               mon_MainLoop:
00FE2A  2  20 E9 FE             jsr     fetchByte                                                      ; FE2A 20 E9 FE      ..
00FE2D  2  C9 2F                cmp     #'/'                                                           ; FE2D C9 2F        ./
00FE2F  2  F0 1E                beq     mon_DataMode                                                   ; FE2F F0 1E        ..
00FE31  2  C9 47                cmp     #'G'                                                           ; FE31 C9 47        .G
00FE33  2  F0 17                beq     mon_GoAddr                                                     ; FE33 F0 17        ..
00FE35  2  C9 4C                cmp     #'L'                                                           ; FE35 C9 4C        .L
00FE37  2  F0 43                beq     mon_SetLoadSaveFlag                                            ; FE37 F0 43        .C
00FE39  2  20 93 FE             jsr     hex2bin                                                        ; FE39 20 93 FE      ..
00FE3C  2  30 EC                bmi     mon_MainLoop                                                   ; FE3C 30 EC        0.
00FE3E  2  A2 02                ldx     #$02                                                           ; FE3E A2 02        ..
00FE40  2  20 DA FE             jsr     rollAD                                                         ; FE40 20 DA FE      ..
00FE43  2               ; Monitor - Display Address
00FE43  2               mon_DspAddr:
00FE43  2  B1 FE                lda     (zp_monLoadAddrLo),y                                           ; FE43 B1 FE        ..
00FE45  2  85 FC                sta     zp_monLoadByte                                                 ; FE45 85 FC        ..
00FE47  2  20 AC FE             jsr     disp4bytes                                                     ; FE47 20 AC FE      ..
00FE4A  2  D0 DE                bne     mon_MainLoop                                                   ; FE4A D0 DE        ..
00FE4C  2               ; Monitor - Execute at Address store at zPage ($FE+$FF)
00FE4C  2               mon_GoAddr:
00FE4C  2  6C FE 00             jmp     (zp_monLoadAddrLo)                                             ; FE4C 6C FE 00     l..
00FE4F  2               
00FE4F  2               ; ----------------------------------------------------------------------------
00FE4F  2               ; Monitor - Data mode
00FE4F  2               mon_DataMode:
00FE4F  2  20 E9 FE             jsr     fetchByte                                                      ; FE4F 20 E9 FE      ..
00FE52  2  C9 2E                cmp     #$2E                                                           ; FE52 C9 2E        ..
00FE54  2  F0 D4                beq     mon_MainLoop                                                   ; FE54 F0 D4        ..
00FE56  2  C9 0D                cmp     #$0D                                                           ; FE56 C9 0D        ..
00FE58  2  D0 0F                bne     mon_DspData                                                    ; FE58 D0 0F        ..
00FE5A  2  E6 FE                inc     zp_monLoadAddrLo                                               ; FE5A E6 FE        ..
00FE5C  2  D0 02                bne     mon_GetByteAt                                                  ; FE5C D0 02        ..
00FE5E  2  E6 FF                inc     zp_monLoadAddrHi                                               ; FE5E E6 FF        ..
00FE60  2               mon_GetByteAt:
00FE60  2  A0 00                ldy     #$00                                                           ; FE60 A0 00        ..
00FE62  2  B1 FE                lda     (zp_monLoadAddrLo),y                                           ; FE62 B1 FE        ..
00FE64  2  85 FC                sta     zp_monLoadByte                                                 ; FE64 85 FC        ..
00FE66  2  4C 77 FE             jmp     mon_DspAddr2                                                   ; FE66 4C 77 FE     Lw.
00FE69  2               
00FE69  2               ; ----------------------------------------------------------------------------
00FE69  2               mon_DspData:
00FE69  2  20 93 FE             jsr     hex2bin                                                        ; FE69 20 93 FE      ..
00FE6C  2  30 E1                bmi     mon_DataMode                                                   ; FE6C 30 E1        0.
00FE6E  2  A2 00                ldx     #$00                                                           ; FE6E A2 00        ..
00FE70  2  20 DA FE             jsr     rollAD                                                         ; FE70 20 DA FE      ..
00FE73  2  A5 FC                lda     zp_monLoadByte                                                 ; FE73 A5 FC        ..
00FE75  2  91 FE                sta     (zp_monLoadAddrLo),y                                           ; FE75 91 FE        ..
00FE77  2               mon_DspAddr2:
00FE77  2  20 AC FE             jsr     disp4bytes                                                     ; FE77 20 AC FE      ..
00FE7A  2  D0 D3                bne     mon_DataMode                                                   ; FE7A D0 D3        ..
00FE7C  2               mon_SetLoadSaveFlag:
00FE7C  2  85 FB                sta     zp_monLoadFlag                                                 ; FE7C 85 FB        ..
00FE7E  2  F0 CF                beq     mon_DataMode                                                   ; FE7E F0 CF        ..
00FE80  2               
00FE80  2               
00FE80  2               ; ----------------------------------------------------------------------------
00FE80  2               ; Get char from the ACIA
00FE80  2               aciaGet:                                                                       ; FE80
00FE80  2  20 88 FE             jsr     aciaGetR
00FE83  2  90 FB                bcc     aciaGet
00FE85  2  29 7F                and     #$7F
00FE87  2  60                   rts
00FE88  2               ;
00FE88  2               aciaGetR:
00FE88  2  AD 00 F0             lda     aciaStatus
00FE8B  2  4A                   lsr     a
00FE8C  2  90 03                bcc     @Done
00FE8E  2  AD 01 F0             lda     aciaData
00FE91  2               @Done:
00FE91  2  60                   rts
00FE92  2               
00FE92  2               ; ----------------------------------------------------------------------------
00FE92  2  00                   .byte   $00  ; ,$00,$00,$00                                                ; FE8F 00 00 00 00  ....
00FE93  2               ; ----------------------------------------------------------------------------
00FE93  2               ; hex2bin - Convert ascii hex to binary
00FE93  2               hex2bin:
00FE93  2  C9 30                cmp     #$30                                                           ; FE93 C9 30        .0
00FE95  2  30 12                bmi     hex2bin_err                                                    ; FE95 30 12        0.
00FE97  2  C9 3A                cmp     #$3A                                                           ; FE97 C9 3A        .:
00FE99  2  30 0B                bmi     hex2bin_ok                                                     ; FE99 30 0B        0.
00FE9B  2  C9 41                cmp     #$41                                                           ; FE9B C9 41        .A
00FE9D  2  30 0A                bmi     hex2bin_err                                                    ; FE9D 30 0A        0.
00FE9F  2  C9 47                cmp     #$47                                                           ; FE9F C9 47        .G
00FEA1  2  10 06                bpl     hex2bin_err                                                    ; FEA1 10 06        ..
00FEA3  2  38                   sec                                                                    ; FEA3 38           8
00FEA4  2  E9 07                sbc     #$07                                                           ; FEA4 E9 07        ..
00FEA6  2               ; hex2bin - Success exit
00FEA6  2               hex2bin_ok:
00FEA6  2  29 0F                and     #$0F                                                           ; FEA6 29 0F        ).
00FEA8  2  60                   rts                                                                    ; FEA8 60           `
00FEA9  2               
00FEA9  2               ; ----------------------------------------------------------------------------
00FEA9  2               ; hex2bin - Error exit
00FEA9  2               hex2bin_err:
00FEA9  2  A9 80                lda     #$80                                                           ; FEA9 A9 80        ..
00FEAB  2  60                   rts                                                                    ; FEAB 60           `
00FEAC  2               
00FEAC  2               ; ----------------------------------------------------------------------------
00FEAC  2               ; Display 4 bytes in $FF, FE, FD & FC
00FEAC  2               disp4bytes:
00FEAC  2  A2 03                ldx     #$03                                                           ; FEAC A2 03        ..
00FEAE  2  A0 00                ldy     #$00                                                           ; FEAE A0 00        ..
00FEB0  2               ; Display 4 bytes - Loop
00FEB0  2               disp4bytes_loop:
00FEB0  2  B5 FC                lda     zp_monLoadByte,x                                               ; FEB0 B5 FC        ..
00FEB2  2  4A                   lsr     a                                                              ; FEB2 4A           J
00FEB3  2  4A                   lsr     a                                                              ; FEB3 4A           J
00FEB4  2  4A                   lsr     a                                                              ; FEB4 4A           J
00FEB5  2  4A                   lsr     a                                                              ; FEB5 4A           J
00FEB6  2  20 CA FE             jsr     dispNybble                                                     ; FEB6 20 CA FE      ..
00FEB9  2  B5 FC                lda     zp_monLoadByte,x                                               ; FEB9 B5 FC        ..
00FEBB  2  20 CA FE             jsr     dispNybble                                                     ; FEBB 20 CA FE      ..
00FEBE  2  CA                   dex                                                                    ; FEBE CA           .
00FEBF  2  10 EF                bpl     disp4bytes_loop                                                ; FEBF 10 EF        ..
00FEC1  2  A9 20                lda     #$20                                                           ; FEC1 A9 20        .
00FEC3  2  8D CA D0             sta     displayRAM+$CA                                                 ; FEC3 8D CA D0     ...
00FEC6  2  8D CB D0             sta     displayRAM+$CB                                                 ; FEC6 8D CB D0     ...
00FEC9  2  60                   rts                                                                    ; FEC9 60           `
00FECA  2               
00FECA  2               ; ----------------------------------------------------------------------------
00FECA  2               ; Display Nybble - A-Reg
00FECA  2               dispNybble:
00FECA  2  29 0F                and     #$0F                                                           ; FECA 29 0F        ).
00FECC  2  09 30                ora     #$30                                                           ; FECC 09 30        .0
00FECE  2  C9 3A                cmp     #$3A                                                           ; FECE C9 3A        .:
00FED0  2  30 03                bmi     dispNybble_exit                                                ; FED0 30 03        0.
00FED2  2  18                   clc                                                                    ; FED2 18           .
00FED3  2  69 07                adc     #$07                                                           ; FED3 69 07        i.
00FED5  2               ; Display Nybble - Exit
00FED5  2               dispNybble_exit:
00FED5  2  99 C6 D0             sta     displayRAM+$C6,y                                               ; FED5 99 C6 D0     ...
00FED8  2  C8                   iny                                                                    ; FED8 C8           .
00FED9  2  60                   rts                                                                    ; FED9 60           `
00FEDA  2               
00FEDA  2               ; ----------------------------------------------------------------------------
00FEDA  2               ; Roll hex digits into 2 bytes of memory target $FC, FD
00FEDA  2               rollAD:
00FEDA  2  A0 04                ldy     #$04                                                           ; FEDA A0 04        ..
00FEDC  2  0A                   asl     a                                                              ; FEDC 0A           .
00FEDD  2  0A                   asl     a                                                              ; FEDD 0A           .
00FEDE  2  0A                   asl     a                                                              ; FEDE 0A           .
00FEDF  2  0A                   asl     a                                                              ; FEDF 0A           .
00FEE0  2               ; Roll hex digits - Loop
00FEE0  2               rollAD_loop:
00FEE0  2  2A                   rol     a                                                              ; FEE0 2A           *
00FEE1  2  36 FC                rol     zp_monLoadByte,x                                               ; FEE1 36 FC        6.
00FEE3  2  36 FD                rol     zp_monLoadTmp,x                                                ; FEE3 36 FD        6.
00FEE5  2  88                   dey                                                                    ; FEE5 88           .
00FEE6  2  D0 F8                bne     rollAD_loop                                                    ; FEE6 D0 F8        ..
00FEE8  2  60                   rts                                                                    ; FEE8 60           `
00FEE9  2               
00FEE9  2               ; ----------------------------------------------------------------------------
00FEE9  2               ; Check Fetch flag; Read from TAPE else KEYB
00FEE9  2               fetchByte:
00FEE9  2  A5 FB                lda     zp_monLoadFlag                                                 ; FEE9 A5 FB        ..
00FEEB  2  D0 93                bne     aciaGet                                                        ; FEEB D0 93        ..
00FEED  2               oneBefore_jumpTable:= * + $0002
00FEED  2  4C 00 FD             jmp     pollKBD                                                        ; FEED 4C 00 FD     L..
00FEF0  2               
00FEF0  2               ; ----------------------------------------------------------------------------
00FEF0  2               jumpTable:
00FEF0  2  BA FF                .addr   inputChar                                                      ; FEF0 BA FF        ..
00FEF2  2  69 FF                .addr   outChar                                                        ; FEF2 69 FF        i.
00FEF4  2  9B FF                .addr   ctrlC                                                          ; FEF4 9B FF        ..
00FEF6  2  8B FF                .addr   setLoadFlag                                                    ; FEF6 8B FF        ..
00FEF8  2  96 FF                .addr   setSaveFlag                                                    ; FEF8 96 FF        ..
00FEFA  2  30 01                .addr   stack+$30                     ; NMI                            ; FEFA 30 01        0.
00FEFC  2  00 FE                .addr   monStart                      ; ???                            ; FEFC 00 FE        ..
00FEFE  2  C0 01                .addr   stack+$C0                     ; IRQ                            ; FEFE C0 01        ..
00FF00  2               ; ----------------------------------------------------------------------------
00FF00  2               ; Cold start - Called on CPU reset
00FF00  2               coldStart:
00FF00  2  A2 28                ldx     #$28                          ; Start of Stack = $28
00FF02  2  9A                   txs                                   ; Xfer into SP
00FF03  2               ;
00FF03  2  20 DC FC             jsr     initIrqNmi                    ; Prep IRQ/NMI handling & finish CPU setup
00FF06  2               ;
00FF06  2  D8                   cld
00FF07  2  A0 0A                ldy     #$0A
00FF09  2  EA                   nop
00FF0A  2  EA                   nop
00FF0B  2  EA                   nop
00FF0C  2  EA                   nop
00FF0D  2               
00FF0D  2               ;                                                                              ; FF04 A0 0A        ..
00FF0D  2               ; Cold start - Copy jump table to wrkArea
00FF0D  2               coldStart_copyJumpTable:                                                       ; THESE ARE WRONG NOW!!!
00FF0D  2  B9 EF FE             lda     oneBefore_jumpTable,y                                          ; FF06 B9 EF FE     ...
00FF10  2  99 17 02             sta     wa_unused2,y                                                   ; FF09 99 17 02     ...
00FF13  2  88                   dey                                                                    ; FF0C 88           .
00FF14  2  D0 F7                bne     coldStart_copyJumpTable                                        ; FF0D D0 F7        ..
00FF16  2  20 A6 FC             jsr     aciaInit                                                       ; FF0F 20 A6 FC      ..
00FF19  2  8C 12 02             sty     wa_ctrl_C_flag                                                 ; FF12 8C 12 02     ...
00FF1C  2  8C 03 02             sty     wa_loadFlag                                                    ; FF15 8C 03 02     ...
00FF1F  2  8C 05 02             sty     wa_saveFlag                                                    ; FF18 8C 05 02     ...
00FF22  2  8C 06 02             sty     wa_repeatRate                                                  ; FF1B 8C 06 02     ...
00FF25  2  AD E0 FF             lda     initialSetup                                                   ; FF1E AD E0 FF     ...
00FF28  2  8D 00 02             sta     wa_cursorAtAddr                                                ; FF21 8D 00 02     ...
00FF2B  2               ;
00FF2B  2  20 rr rr             jsr     clrScreen
00FF2E  2               ;
00FF2E  2               coldStart_dspPrompt:
00FF2E  2  B9 5F FF             lda     dcwmPrompt,y                                                   ; FF35 B9 5F FF     ._.
00FF31  2  F0 06                beq     coldStart_goMonStart                                           ; FF38 F0 06        ..
00FF33  2  20 2D BF             jsr     basicROM_crtRtn                                                ; FF3A 20 2D BF      -.
00FF36  2  C8                   iny                                                                    ; FF3D C8           .
00FF37  2  D0 F5                bne     coldStart_dspPrompt                                            ; FF3E D0 F5        ..
00FF39  2               ;
00FF39  2               ; Cold start - goto Mon Start?
00FF39  2               coldStart_goMonStart:
00FF39  2  20 BA FF             jsr     inputChar                                                      ; FF40 20 BA FF      ..
00FF3C  2  C9 4D                cmp     #'M'                                                           ; FF43 C9 4D        .M
00FF3E  2  D0 03                bne     coldStart_goWarmStartBASIC                                     ; FF45 D0 03        ..
00FF40  2  4C 00 FE             jmp     monStart                                                       ; FF47 4C 00 FE     L..
00FF43  2               
00FF43  2               ; ----------------------------------------------------------------------------
00FF43  2               ; Cold start - goto Warm Start BASIC?
00FF43  2               coldStart_goWarmStartBASIC:
00FF43  2  C9 57                cmp     #'W'                                                           ; FF4A C9 57        .W
00FF45  2  D0 03                bne     coldStart_goColdStartBASIC                                     ; FF4C D0 03        ..
00FF47  2  4C 00 00             jmp     zp_bas_JmpWarm                                                 ; FF4E 4C 00 00     L..
00FF4A  2               
00FF4A  2               ; ----------------------------------------------------------------------------
00FF4A  2               ; Cold start - goto Cold Start BASIC?
00FF4A  2               coldStart_goColdStartBASIC:
00FF4A  2  C9 43                cmp     #'C'                                                           ; FF51 C9 43        .C
00FF4C  2  D0 03                bne     coldStart_goDiskStart                                          ; FF53 D0 03        ..
00FF4E  2  4C 11 BD             jmp     basicROM_coldStart                                             ; FF55 4C 11 BD     L..
00FF51  2               
00FF51  2               ; ----------------------------------------------------------------------------
00FF51  2               ; Cold start - goto Disk Start!
00FF51  2               coldStart_goDiskStart:
00FF51  2  C9 44                cmp     #'D'
00FF53  2  D0 03                bne     coldstart_Xmodem
00FF55  2  4C 00 FC             jmp     dskBoot
00FF58  2               ; ----------------------------------------------------------------------------
00FF58  2               ; Cold start - goto XModem start
00FF58  2               coldstart_Xmodem:
00FF58  2  C9 58                cmp     #'X'
00FF5A  2  D0 A4                bne     coldStart
00FF5C  2  4C rr rr             jmp     XM_RomStart
00FF5F  2               ; ----------------------------------------------------------------------------
00FF5F  2               dcwmPrompt:
00FF5F  2  44 2F 43 2F          .byte   "D/C/W/M/X"                                                    ; FF5F 44 2F 43 2F 57 2F 4D 20D/C/W/M
00FF63  2  57 2F 4D 2F  
00FF67  2  58           
00FF68  2                                                                                              ; FF67 3F           ?
00FF68  2  00                   .byte   $00                                                            ; FF68 00           .
00FF69  2               ; ----------------------------------------------------------------------------
00FF69  2               ; Output char to screen and/or TAPE(ACIA)
00FF69  2               outChar:
00FF69  2  20 2D BF             jsr     basicROM_crtRtn                                                ; FF69 20 2D BF      -.
00FF6C  2  48                   pha                                                                    ; FF6C 48           H
00FF6D  2  AD 05 02             lda     wa_saveFlag                                                    ; FF6D AD 05 02     ...
00FF70  2  F0 22                beq     outChar_exitRestore_A                                          ; FF70 F0 22        ."
00FF72  2  68                   pla                                                                    ; FF72 68           h
00FF73  2  20 B1 FC             jsr     aciaPut                                                        ; FF73 20 B1 FC      ..
00FF76  2  C9 0D                cmp     #$0D                                                           ; FF76 C9 0D        ..
00FF78  2  D0 1B                bne     outChar_exit                                                   ; FF78 D0 1B        ..
00FF7A  2  48                   pha                                                                    ; FF7A 48           H
00FF7B  2  8A                   txa                                                                    ; FF7B 8A           .
00FF7C  2  48                   pha                                                                    ; FF7C 48           H
00FF7D  2  A2 0A                ldx     #$0A                                                           ; FF7D A2 0A        ..
00FF7F  2  A9 00                lda     #$00                                                           ; FF7F A9 00        ..
00FF81  2               outChar_loop:
00FF81  2  20 B1 FC             jsr     aciaPut                                                        ; FF81 20 B1 FC      ..
00FF84  2  CA                   dex                                                                    ; FF84 CA           .
00FF85  2  D0 FA                bne     outChar_loop                                                   ; FF85 D0 FA        ..
00FF87  2  68                   pla                                                                    ; FF87 68           h
00FF88  2  AA                   tax                                                                    ; FF88 AA           .
00FF89  2  68                   pla                                                                    ; FF89 68           h
00FF8A  2  60                   rts                                                                    ; FF8A 60           `
00FF8B  2               
00FF8B  2               ; ----------------------------------------------------------------------------
00FF8B  2               ; Set LOAD flag, reset SAVE flag
00FF8B  2               setLoadFlag:
00FF8B  2  48                   pha                                                                    ; FF8B 48           H
00FF8C  2  CE 03 02             dec     wa_loadFlag                                                    ; FF8C CE 03 02     ...
00FF8F  2  A9 00                lda     #$00                                                           ; FF8F A9 00        ..
00FF91  2               ; Store the LOAD/SAVE flag
00FF91  2               storeLSFlag:
00FF91  2  8D 05 02             sta     wa_saveFlag                                                    ; FF91 8D 05 02     ...
00FF94  2               outChar_exitRestore_A:
00FF94  2  68                   pla                                                                    ; FF94 68           h
00FF95  2               outChar_exit:
00FF95  2  60                   rts                                                                    ; FF95 60           `
00FF96  2               
00FF96  2               ; ----------------------------------------------------------------------------
00FF96  2               ; Set SAVE flag
00FF96  2               setSaveFlag:
00FF96  2  48                   pha                                                                    ; FF96 48           H
00FF97  2  A9 01                lda     #$01                                                           ; FF97 A9 01        ..
00FF99  2  D0 F6                bne     storeLSFlag                                                    ; FF99 D0 F6        ..
00FF9B  2               ; Control-C Check - CTRL-C disable flag in wrkArea+12
00FF9B  2               ctrlC:
00FF9B  2  AD 12 02             lda     wa_ctrl_C_flag                                                 ; FF9B AD 12 02     ...
00FF9E  2  D0 19                bne     ctrlC_ignore                                                   ; FF9E D0 19        ..
00FFA0  2  A9 FE                lda     #$FE                                                           ; FFA0 A9 FE        ..
00FFA2  2  8D 00 DF             sta     kbdPort                                                        ; FFA2 8D 00 DF     ...
00FFA5  2  2C 00 DF             bit     kbdPort                                                        ; FFA5 2C 00 DF     ,..
00FFA8  2  70 0F                bvs     ctrlC_ignore                                                   ; FFA8 70 0F        p.
00FFAA  2  A9 FB                lda     #$FB                                                           ; FFAA A9 FB        ..
00FFAC  2  8D 00 DF             sta     kbdPort                                                        ; FFAC 8D 00 DF     ...
00FFAF  2  2C 00 DF             bit     kbdPort                                                        ; FFAF 2C 00 DF     ,..
00FFB2  2  70 05                bvs     ctrlC_ignore                                                   ; FFB2 70 05        p.
00FFB4  2  A9 03                lda     #$03                                                           ; FFB4 A9 03        ..
00FFB6  2  4C 36 A6             jmp     basicROM_CTRL_C+$0D                                            ; FFB6 4C 36 A6     L6.
00FFB9  2               
00FFB9  2               ; ----------------------------------------------------------------------------
00FFB9  2               ctrlC_ignore:
00FFB9  2  60                   rts                                                                    ; FFB9 60           `
00FFBA  2               
00FFBA  2               ; ----------------------------------------------------------------------------
00FFBA  2               ; Input char from KBD and/or TAPE(ACIA)
00FFBA  2               inputChar:
00FFBA  2  2C 03 02             bit     wa_loadFlag                                                    ; FFBA 2C 03 02     ,..
00FFBD  2  10 19                bpl     inputChar_kbd                                                  ; FFBD 10 19        ..
00FFBF  2               inputChar_loopACIA:
00FFBF  2  A9 FD                lda     #$FD                                                           ; FFBF A9 FD        ..
00FFC1  2  8D 00 DF             sta     kbdPort                                                        ; FFC1 8D 00 DF     ...
00FFC4  2  A9 10                lda     #$10                                                           ; FFC4 A9 10        ..
00FFC6  2  2C 00 DF             bit     kbdPort                                                        ; FFC6 2C 00 DF     ,..
00FFC9  2  F0 0A                beq     inputChar_endACIA                                              ; FFC9 F0 0A        ..
00FFCB  2  AD 00 F0             lda     aciaStatus                                                     ; FFCB AD 00 F0     ...
00FFCE  2  4A                   lsr     a                                                              ; FFCE 4A           J
00FFCF  2  90 EE                bcc     inputChar_loopACIA                                             ; FFCF 90 EE        ..
00FFD1  2  AD 01 F0             lda     aciaData                                                       ; FFD1 AD 01 F0     ...
00FFD4  2  60                   rts                                                                    ; FFD4 60           `
00FFD5  2               
00FFD5  2               ; ----------------------------------------------------------------------------
00FFD5  2               inputChar_endACIA:
00FFD5  2  EE 03 02             inc     wa_loadFlag                                                    ; FFD5 EE 03 02     ...
00FFD8  2               inputChar_kbd:
00FFD8  2  4C 00 FD             jmp     pollKBD                                                        ; FFD8 4C 00 FD     L..
00FFDB  2               
00FFDB  2               ; ----------------------------------------------------------------------------
00FFDB  2  FF FF FF FF          .byte   $FF,$FF,$FF,$FF,$FF                                            ; FFDB FF FF FF FF FF.....
00FFDF  2  FF           
00FFE0  2               initialSetup:
00FFE0  2  65 17 00 00          .byte   $65,$17,$00,$00,$03,$FF,$9F,$00                                ; FFE0 65 17 00 00 03 FF 9F 00e.......
00FFE4  2  03 FF 9F 00  
00FFE8  2  03 FF 9F             .byte   $03,$FF,$9F                                                    ; FFE8 03 FF 9F     ...
00FFEB  2               ; ----------------------------------------------------------------------------
00FFEB  2               ; Input Routine
00FFEB  2               inputRtn:
00FFEB  2  6C 18 02             jmp     (wa_inputVec)                                                  ; FFEB 6C 18 02     l..
00FFEE  2               
00FFEE  2               ; ----------------------------------------------------------------------------
00FFEE  2               ; Output Routine
00FFEE  2               outputRtn:
00FFEE  2  6C 1A 02             jmp     (wa_outputVec)                                                 ; FFEE 6C 1A 02     l..
00FFF1  2               
00FFF1  2               ; ----------------------------------------------------------------------------
00FFF1  2               ; Ctrl-C Routine
00FFF1  2               crtl_CRtn:
00FFF1  2  6C 1C 02             jmp     (wa_ctrlCVec)                                                  ; FFF1 6C 1C 02     l..
00FFF4  2               
00FFF4  2               ; ----------------------------------------------------------------------------
00FFF4  2               ; Load Routine
00FFF4  2               loadRtn:
00FFF4  2  6C 1E 02             jmp     (wa_loadVec)                                                   ; FFF4 6C 1E 02     l..
00FFF7  2               
00FFF7  2               ; ----------------------------------------------------------------------------
00FFF7  2               ; Save Routine
00FFF7  2               saveRtn:
00FFF7  2  6C 20 02             jmp     (wa_saveVec)                                                   ; FFF7 6C 20 02     l .
00FFFA  2               
00FFFA  2               ; ----------------------------------------------------------------------------
00FFFA  2               CPU_nmi:
00FFFA  2  D8 FC                .addr   nmiJump
00FFFC  2               ;       .addr   stack+$30                                                      ; FFFA 30 01        0.
00FFFC  2               CPU_res:
00FFFC  2  00 FF                .addr   coldStart                                                      ; FFFC 00 FF        ..
00FFFE  2               CPU_irq:
00FFFE  2  D5 FC                .addr   irqJump
010000  2               ;       .addr   stack+$C0                                                      ; FFFE C0 01        ..
010000  2               .reloc     ; back to normal
000800r 2               
000800r 1               ;
000800r 1               ;
000800r 1               
